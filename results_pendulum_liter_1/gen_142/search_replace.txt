Looking at the performance metrics, all programs are plateauing at ~4920 points with identical stabilization_time=192 and stable_x_error=0.03. The time bonus (2233.79) and energy bonus (2492.85) are the dominant factors, so reducing stabilization time even by 1-2 steps could yield significant gains.

<NAME>
aggressive_early_phase_control
</NAME>

<DESCRIPTION>
The key insight is that all current solutions stabilize at exactly 192 steps, suggesting a bottleneck in the early transient phase. The current gain scheduling only activates above 0.6 rad for position and 1.0 rad/s for velocity, which may be too conservative during the critical initial recovery from 0.4 rad.

I propose a two-phase control strategy:
1. **Early aggressive phase** (first ~50 steps): Use higher gains to accelerate initial convergence when the system has high energy and needs rapid correction
2. **Precision phase** (after settling): Transition to the proven LQR gains for fine-tuning

Additionally, I'll sharpen the gain scheduling transitions (as suggested in recommendation 5) to enable faster mode switching, and add a small predictive term based on angular acceleration to anticipate pole dynamics better.

The physics insight: with a 2.5m pole, the natural period is ~2.25s (112 steps). We need to "catch" the pole within the first half-period to avoid oscillation buildup. More aggressive early control can achieve this.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def __init__(self):
        # System parameters
        m = M_POLE
        M = M_CART
        l = L_COM
        g = G
        Mtot = M + m
        denom0 = l * (4.0 / 3.0 - m / Mtot)
        b_c = FRICTION_CART
        b_j = FRICTION_JOINT

        # Physically accurate linearized A matrix with corrected joint friction
        A = np.zeros((4, 4))
        A[0, 2] = 1.0
        A[1, 3] = 1.0

        # theta_acc row (3) - using corrected joint friction term matching simulator
        A[3, 1] = g / denom0
        A[3, 2] = b_c / (Mtot * denom0)
        A[3, 3] = -b_j / (m * l * denom0)  # Matches simulator: f_joint/(m*l) / denom0

        # x_acc row (2)
        A[2, 1] = -(m * l / Mtot) * A[3, 1]
        A[2, 2] = -b_c / Mtot - (m * l / Mtot) * A[3, 2]
        A[2, 3] = b_j / (Mtot * denom0)

        # B matrix
        B = np.zeros((4, 1))
        B[2, 0] = 1.0 / Mtot + (m * l) / (Mtot**2 * denom0)
        B[3, 0] = -1.0 / (Mtot * denom0)

        # Optimized LQR weights: proven configuration from best performer (4920.14)
        Q = np.diag([4.5, 44.0, 0.6, 3.2])  # Restored best-performing weights
        R = np.array([[1.0]])

        # Solve LQR gains
        self.K = self.solve_lqr(A, B, Q, R)

        # Natural frequency for normalized falling severity
        self.omega_n = np.sqrt(G / L_COM)

        # Integral control for cart position
        self.integral_x = 0.0
        self.K_i = 0.05
=======
    def __init__(self):
        # System parameters
        m = M_POLE
        M = M_CART
        l = L_COM
        g = G
        Mtot = M + m
        denom0 = l * (4.0 / 3.0 - m / Mtot)
        b_c = FRICTION_CART
        b_j = FRICTION_JOINT

        # Physically accurate linearized A matrix with corrected joint friction
        A = np.zeros((4, 4))
        A[0, 2] = 1.0
        A[1, 3] = 1.0

        # theta_acc row (3) - using corrected joint friction term matching simulator
        A[3, 1] = g / denom0
        A[3, 2] = b_c / (Mtot * denom0)
        A[3, 3] = -b_j / (m * l * denom0)  # Matches simulator: f_joint/(m*l) / denom0

        # x_acc row (2)
        A[2, 1] = -(m * l / Mtot) * A[3, 1]
        A[2, 2] = -b_c / Mtot - (m * l / Mtot) * A[3, 2]
        A[2, 3] = b_j / (Mtot * denom0)

        # B matrix
        B = np.zeros((4, 1))
        B[2, 0] = 1.0 / Mtot + (m * l) / (Mtot**2 * denom0)
        B[3, 0] = -1.0 / (Mtot * denom0)

        # Optimized LQR weights: proven configuration from best performer (4920.14)
        Q = np.diag([4.5, 44.0, 0.6, 3.2])  # Restored best-performing weights
        R = np.array([[1.0]])

        # Solve LQR gains
        self.K = self.solve_lqr(A, B, Q, R)

        # Natural frequency for normalized falling severity
        self.omega_n = np.sqrt(G / L_COM)

        # Integral control for cart position
        self.integral_x = 0.0
        self.K_i = 0.05

        # Step counter for early-phase boost
        self.step_count = 0

        # Previous dtheta for acceleration estimation
        self.prev_dtheta = 0.0
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def get_action(self, state):
        """Adaptive LQR control with swing-up assist and integral control"""
        x, theta, dx, dtheta = state

        # Robust angle normalization using arctan2
        theta = np.arctan2(np.sin(theta), np.cos(theta))

        state_vec = np.array([x, theta, dx, dtheta])
        base_force = -self.K @ state_vec

        # Smooth gain scheduling using tanh activation
        pos_gain = 1.0 + 0.5 * np.tanh(5.0 * max(0.0, abs(theta) - 0.6))
        vel_gain = 1.0 + 0.3 * np.tanh(4.0 * max(0.0, abs(dtheta) - 1.0))

        # Combined multiplicative gain
        adaptive_gain = pos_gain * vel_gain
        force = base_force * adaptive_gain

        # Physics-informed swing-up assist for large angles (>0.8 rad)
        if abs(theta) > 0.8:
            # Normalized divergence metric: angular momentum scaled by natural frequency
            norm_momentum = (theta * dtheta) / (self.omega_n * L_COM)
            # Smooth activation based on angle deviation
            swing_activation = np.tanh(6.0 * (abs(theta) - 0.8))
            # Continuous falling severity: tanh for differentiable divergence scaling
            falling_severity = 1.0 + np.tanh(3.0 * norm_momentum)
            # Additive assist force
            u_swing = 8.0 * swing_activation * np.sign(theta) * falling_severity
            force += u_swing

        # Soft-switched integral action: activates only when nearly upright
        gate = np.tanh(12.0 * (0.1 - abs(theta)))
        self.integral_x += x * DT * gate
        # Leaky integration to prevent windup
        self.integral_x *= 0.95
        self.integral_x = np.clip(self.integral_x, -0.5, 0.5)
        force -= self.K_i * self.integral_x * gate

        return float(force[0])
=======
    def get_action(self, state):
        """Adaptive LQR control with swing-up assist and integral control"""
        x, theta, dx, dtheta = state

        # Robust angle normalization using arctan2
        theta = np.arctan2(np.sin(theta), np.cos(theta))

        # Estimate angular acceleration for predictive control
        theta_acc_est = (dtheta - self.prev_dtheta) / DT
        self.prev_dtheta = dtheta
        self.step_count += 1

        state_vec = np.array([x, theta, dx, dtheta])
        base_force = -self.K @ state_vec

        # Early-phase boost: more aggressive control in first 60 steps
        # Decays smoothly to 1.0 as system settles
        early_boost = 1.0 + 0.15 * np.exp(-self.step_count / 25.0)

        # Sharper gain scheduling using steeper tanh slopes for crisper mode separation
        pos_gain = 1.0 + 0.5 * np.tanh(7.0 * max(0.0, abs(theta) - 0.5))  # Lower threshold, steeper
        vel_gain = 1.0 + 0.3 * np.tanh(6.0 * max(0.0, abs(dtheta) - 0.8))  # Lower threshold, steeper

        # Combined multiplicative gain with early boost
        adaptive_gain = pos_gain * vel_gain * early_boost
        force = base_force * adaptive_gain

        # Predictive correction: anticipate pole dynamics using acceleration
        # Small term to counteract impending falls before they develop
        if abs(theta) > 0.15 and abs(theta) < 0.8:
            pred_correction = 0.8 * np.sign(theta) * np.tanh(2.0 * theta_acc_est)
            force += pred_correction

        # Physics-informed swing-up assist for large angles (>0.8 rad)
        if abs(theta) > 0.8:
            # Normalized divergence metric: angular momentum scaled by natural frequency
            norm_momentum = (theta * dtheta) / (self.omega_n * L_COM)
            # Smooth activation based on angle deviation
            swing_activation = np.tanh(6.0 * (abs(theta) - 0.8))
            # Continuous falling severity: tanh for differentiable divergence scaling
            falling_severity = 1.0 + np.tanh(3.0 * norm_momentum)
            # Additive assist force
            u_swing = 8.0 * swing_activation * np.sign(theta) * falling_severity
            force += u_swing

        # Soft-switched integral action with joint angle-velocity gating
        angle_gate = np.tanh(12.0 * (0.1 - abs(theta)))
        velocity_gate = np.tanh(8.0 * (0.5 - abs(dtheta)))  # Suppress when moving fast
        gate = angle_gate * velocity_gate
        self.integral_x += x * DT * gate
        # Leaky integration to prevent windup
        self.integral_x *= 0.95
        self.integral_x = np.clip(self.integral_x, -0.5, 0.5)
        force -= self.K_i * self.integral_x * gate

        return float(force[0])
>>>>>>> REPLACE
</DIFF>
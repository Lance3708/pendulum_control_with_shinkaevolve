<NAME>
discrete_time_lqr_with_tuned_gains
</NAME>

<DESCRIPTION>
The current controller uses continuous-time LQR (solve_continuous_are) but the simulator uses Euler integration (discrete-time). This mismatch introduces phase lag that slows stabilization. By switching to discrete-time LQR via zero-order hold discretization (using scipy.signal.cont2discrete and scipy.linalg.solve_discrete_are), the control law will be properly aligned with the actual system dynamics.

Additionally, I'll slightly increase Q[3] from 3.2 to 3.28 as suggested, which has shown marginal improvements in damping post-swing oscillations without energy penalty. The discrete-time formulation combined with fine-tuned gains should reduce stabilization time below 192 steps, directly improving the time bonus which is the largest scoring component.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def __init__(self):
        # System parameters
        m = M_POLE
        M = M_CART
        l = L_COM
        g = G
        Mtot = M + m
        denom0 = l * (4.0 / 3.0 - m / Mtot)
        b_c = FRICTION_CART
        b_j = FRICTION_JOINT

        # Runtime validation of physics consistency
        assert abs(FRICTION_CART - 0.35) < 1e-6, "Cart friction mismatch"
        assert abs(FRICTION_JOINT - 0.25) < 1e-6, "Joint friction mismatch"
        assert abs(L_COM - 1.25) < 1e-6, "Pole length mismatch"

        # Physically accurate linearized A matrix with consistent denom0 usage
        A = np.zeros((4, 4))
        A[0, 2] = 1.0
        A[1, 3] = 1.0

        # theta_acc row (3) - fully consistent with simulator denominator structure
        A[3, 1] = g / denom0
        A[3, 2] = b_c / (Mtot * denom0)
        A[3, 3] = -b_j / (m * l * denom0)  # Now perfectly matches simulator physics

        # x_acc row (2)
        A[2, 1] = -(m * l / Mtot) * A[3, 1]
        A[2, 2] = -b_c / Mtot - (m * l / Mtot) * A[3, 2]
        A[2, 3] = b_j / (Mtot * denom0)

        # B matrix
        B = np.zeros((4, 1))
        B[2, 0] = 1.0 / Mtot + (m * l) / (Mtot**2 * denom0)
        B[3, 0] = -1.0 / (Mtot * denom0)

        # Optimized LQR weights: increased penalties for faster stabilization
        Q = np.diag([4.5, 44.0, 0.6, 3.2])  # Increased from [4.0, 38.0, 0.5, 3.0]
        R = np.array([[1.0]])

        # Solve LQR gains
        self.K = self.solve_lqr(A, B, Q, R)
=======
    def __init__(self):
        # System parameters
        m = M_POLE
        M = M_CART
        l = L_COM
        g = G
        Mtot = M + m
        denom0 = l * (4.0 / 3.0 - m / Mtot)
        b_c = FRICTION_CART
        b_j = FRICTION_JOINT

        # Runtime validation of physics consistency
        assert abs(FRICTION_CART - 0.35) < 1e-6, "Cart friction mismatch"
        assert abs(FRICTION_JOINT - 0.25) < 1e-6, "Joint friction mismatch"
        assert abs(L_COM - 1.25) < 1e-6, "Pole length mismatch"

        # Physically accurate linearized A matrix with consistent denom0 usage
        A = np.zeros((4, 4))
        A[0, 2] = 1.0
        A[1, 3] = 1.0

        # theta_acc row (3) - fully consistent with simulator denominator structure
        A[3, 1] = g / denom0
        A[3, 2] = b_c / (Mtot * denom0)
        A[3, 3] = -b_j / (m * l * denom0)  # Now perfectly matches simulator physics

        # x_acc row (2)
        A[2, 1] = -(m * l / Mtot) * A[3, 1]
        A[2, 2] = -b_c / Mtot - (m * l / Mtot) * A[3, 2]
        A[2, 3] = b_j / (Mtot * denom0)

        # B matrix
        B = np.zeros((4, 1))
        B[2, 0] = 1.0 / Mtot + (m * l) / (Mtot**2 * denom0)
        B[3, 0] = -1.0 / (Mtot * denom0)

        # Optimized LQR weights: slightly increased Q[3] for better damping
        Q = np.diag([4.5, 44.0, 0.6, 3.28])
        R = np.array([[1.0]])

        # Solve discrete-time LQR for alignment with Euler integration
        self.K = self.solve_discrete_lqr(A, B, Q, R, DT)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def solve_lqr(self, A, B, Q, R):
        """Solve continuous-time LQR"""
        from scipy.linalg import solve_continuous_are
        P = solve_continuous_are(A, B, Q, R)
        K = np.linalg.inv(R) @ B.T @ P
        return K
=======
    def solve_discrete_lqr(self, A, B, Q, R, dt):
        """Solve discrete-time LQR using ZOH discretization for Euler integration alignment"""
        from scipy.signal import cont2discrete
        from scipy.linalg import solve_discrete_are

        # Discretize continuous system using zero-order hold
        Ad, Bd, _, _, _ = cont2discrete((A, B, np.eye(4), np.zeros((4, 1))), dt, method='zoh')

        # Solve discrete-time algebraic Riccati equation
        P = solve_discrete_are(Ad, Bd, Q, R)

        # Compute discrete LQR gain
        K = np.linalg.inv(R + Bd.T @ P @ Bd) @ (Bd.T @ P @ Ad)
        return K
>>>>>>> REPLACE
</DIFF>
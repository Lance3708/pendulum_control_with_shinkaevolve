**Analysis and Proposed Improvements**

The current controller performs well (4920.15 score) but has room for improvement in stabilization time (192 steps) and steady-state position error (stable_x_error: 0.03). Based on the performance patterns and expert knowledge, I propose two targeted enhancements:

1. **Increase angular velocity damping** to reduce post-swing oscillations
2. **Add gated integral action** to eliminate steady-state position error

Here are the specific changes:

<NAME>
increase_angular_velocity_damping
</NAME>

<DESCRIPTION>
Increase the angular velocity weight in the Q matrix from 3.2 to 3.28 to provide better damping of post-swing oscillations. This small adjustment should help reduce stabilization time by minimizing overshoot and oscillations near equilibrium while maintaining energy efficiency.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        # Proven optimal LQR weights from best performer (4920.14)
        Q = np.diag([4.5, 44.0, 0.6, 3.2])
        R = np.array([[1.0]])
=======
        # Fine-tuned LQR weights with increased angular velocity damping
        Q = np.diag([4.5, 44.0, 0.6, 3.28])
        R = np.array([[1.0]])
>>>>>>> REPLACE
</DIFF>

<NAME>
add_gated_integral_action
</NAME>

<DESCRIPTION>
Introduce soft-switched integral action on cart position that only activates when the pole is nearly upright (<0.1 rad). This eliminates steady-state position error (stable_x_error: 0.03) without interfering with large-angle recovery. The integral term is smoothly gated using tanh to prevent instability during aggressive maneuvers.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def get_action(self, state):
        """Enhanced adaptive LQR with swing-up assist for large angles"""
        x, theta, dx, dtheta = state

        # Robust angle normalization with numerical safety
        theta = ((theta + np.pi + 1e-8) % (2 * np.pi)) - np.pi

        state_vec = np.array([x, theta, dx, dtheta])
        base_force = -self.K @ state_vec

        # Smooth gain scheduling using tanh activation (proven optimal)
        pos_gain = 1.0 + 0.5 * np.tanh(5.0 * max(0.0, abs(theta) - 0.6))
        vel_gain = 1.0 + 0.3 * np.tanh(4.0 * max(0.0, abs(dtheta) - 1.0))

        # Combined multiplicative gain
        adaptive_gain = pos_gain * vel_gain
        force = base_force * adaptive_gain

        # Additive swing-up assist for large angles (>0.8 rad)
        # Provides extra corrective impulse when pole is falling away from equilibrium
        if abs(theta) > 0.8:
            # Physics-informed assist: push cart in direction to catch falling pole
            swing_activation = np.tanh(6.0 * (abs(theta) - 0.8))
            # If theta*dtheta > 0, pole is falling further - need stronger correction
            falling_factor = 1.0 + 0.5 * float(theta * dtheta > 0)
            u_swing = 8.0 * swing_activation * np.sign(theta) * falling_factor
            force = force + u_swing

        return float(force[0])
=======
    def __init__(self):
        # System parameters
        m = M_POLE
        M = M_CART
        l = L_COM
        g = G
        Mtot = M + m
        denom0 = l * (4.0 / 3.0 - m / Mtot)
        b_c = FRICTION_CART
        b_j = FRICTION_JOINT

        # Physically accurate linearized A matrix
        A = np.zeros((4, 4))
        A[0, 2] = 1.0
        A[1, 3] = 1.0
        A[3, 1] = g / denom0
        A[3, 2] = b_c / (Mtot * denom0)
        A[3, 3] = -b_j / (m * l * denom0)
        A[2, 1] = -(m * l / Mtot) * A[3, 1]
        A[2, 2] = -b_c / Mtot - (m * l / Mtot) * A[3, 2]
        A[2, 3] = b_j / (Mtot * denom0)

        # B matrix
        B = np.zeros((4, 1))
        B[2, 0] = 1.0 / Mtot + (m * l) / (Mtot**2 * denom0)
        B[3, 0] = -1.0 / (Mtot * denom0)

        # Fine-tuned LQR weights with increased angular velocity damping
        Q = np.diag([4.5, 44.0, 0.6, 3.28])
        R = np.array([[1.0]])

        # Solve LQR gains
        self.K = self.solve_lqr(A, B, Q, R)

        # Integral term for position error
        self.integral_x = 0.0

    def get_action(self, state):
        """Enhanced adaptive LQR with swing-up assist and gated integral action"""
        x, theta, dx, dtheta = state

        # Robust angle normalization with numerical safety
        theta = ((theta + np.pi + 1e-8) % (2 * np.pi)) - np.pi

        state_vec = np.array([x, theta, dx, dtheta])
        base_force = -self.K @ state_vec

        # Smooth gain scheduling using tanh activation (proven optimal)
        pos_gain = 1.0 + 0.5 * np.tanh(5.0 * max(0.0, abs(theta) - 0.6))
        vel_gain = 1.0 + 0.3 * np.tanh(4.0 * max(0.0, abs(dtheta) - 1.0))

        # Combined multiplicative gain
        adaptive_gain = pos_gain * vel_gain
        force = base_force * adaptive_gain

        # Additive swing-up assist for large angles (>0.8 rad)
        # Provides extra corrective impulse when pole is falling away from equilibrium
        if abs(theta) > 0.8:
            # Physics-informed assist: push cart in direction to catch falling pole
            swing_activation = np.tanh(6.0 * (abs(theta) - 0.8))
            # If theta*dtheta > 0, pole is falling further - need stronger correction
            falling_factor = 1.0 + 0.5 * float(theta * dtheta > 0)
            u_swing = 8.0 * swing_activation * np.sign(theta) * falling_factor
            force = force + u_swing

        # Gated integral action for position error (only when pole is nearly upright)
        integral_gate = np.tanh(12.0 * (0.1 - abs(theta)))
        self.integral_x += x * DT
        integral_force = -0.8 * integral_gate * self.integral_x
        force += integral_force

        return float(force[0])
>>>>>>> REPLACE
</DIFF>

These changes work synergistically:
1. The increased angular velocity damping reduces oscillations for faster stabilization
2. The gated integral action eliminates steady-state position error without compromising stability
3. Both improvements maintain the excellent energy efficiency (0.01 energy/step) while potentially reducing stabilization time below 192 steps

The integral action is carefully designed to only activate when the pole is nearly upright (<0.1 rad), ensuring it doesn't interfere with the critical swing-up phase. This should push the score beyond 4920 by improving both time bonus and success bonus components.
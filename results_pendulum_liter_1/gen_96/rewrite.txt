import numpy as np

# --- Physics Constants ---
M_CART = 1.0       # Mass of the cart (kg)
M_POLE = 0.35      # Mass of the pole (kg) - 更重，大幅增加控制难度
L_POLE = 2.5       # Total length of the pole (m) - 更长，极不稳定
L_COM = L_POLE / 2 # Length to center of mass (m)
G = 9.81           # Gravity (m/s^2)
FRICTION_CART = 0.35 # Coefficient of friction for cart - 高摩擦，更多能量损失
FRICTION_JOINT = 0.25 # Coefficient of friction for joint - 高关节摩擦
DT = 0.02          # Time step (s)
MAX_STEPS = 1000   # 20 seconds simulation

def simulate_pendulum_step(state, force, dt):
    """
    Simulates one time step of the Single Inverted Pendulum.
    """
    x, theta, dx, dtheta = state

    sin_theta = np.sin(theta)
    cos_theta = np.cos(theta)
    M_total = M_CART + M_POLE

    f_cart = -FRICTION_CART * dx
    f_joint = -FRICTION_JOINT * dtheta

    temp = (force + f_cart + M_POLE * L_COM * dtheta**2 * sin_theta) / M_total

    theta_acc = (G * sin_theta - cos_theta * temp + f_joint / (M_POLE * L_COM)) / \
                (L_COM * (4.0/3.0 - M_POLE * cos_theta**2 / M_total))

    x_acc = temp - (M_POLE * L_COM * theta_acc * cos_theta) / M_total

    next_x = x + dx * dt
    next_theta = theta + dtheta * dt
    next_dx = dx + x_acc * dt
    next_dtheta = dtheta + theta_acc * dt

    return np.array([next_x, next_theta, next_dx, next_dtheta])


# EVOLVE-BLOCK-START
class PhaseBasedController:
    """
    Phase-Based Controller Architecture
    Separates control into distinct phases with smooth blending for optimal performance.
    """
    
    # Phase boundaries
    RECOVERY_THRESHOLD = 0.7    # Above this: recovery phase
    PRECISION_THRESHOLD = 0.15  # Below this: precision phase with integral
    
    def __init__(self):
        # Build system matrices
        self.K = self._compute_lqr_gains()
        
        # Integral state for cart position (activated in precision phase)
        self.x_integral = 0.0
        self.integral_gain = 0.08  # Soft integral gain for steady-state correction
        
        # Natural frequency for physics-based scaling
        self.omega_n = np.sqrt(G / L_COM)
        
    def _compute_lqr_gains(self):
        """Compute LQR gains with friction-aware linearization"""
        m = M_POLE
        M = M_CART
        l = L_COM
        g = G
        Mtot = M + m
        denom0 = l * (4.0 / 3.0 - m / Mtot)
        b_c = FRICTION_CART
        b_j = FRICTION_JOINT

        # Linearized A matrix
        A = np.zeros((4, 4))
        A[0, 2] = 1.0
        A[1, 3] = 1.0
        A[3, 1] = g / denom0
        A[3, 2] = b_c / (Mtot * denom0)
        A[3, 3] = -b_j / (m * l * denom0)
        A[2, 1] = -(m * l / Mtot) * A[3, 1]
        A[2, 2] = -b_c / Mtot - (m * l / Mtot) * A[3, 2]
        A[2, 3] = b_j / (Mtot * denom0)

        # B matrix
        B = np.zeros((4, 1))
        B[2, 0] = 1.0 / Mtot + (m * l) / (Mtot**2 * denom0)
        B[3, 0] = -1.0 / (Mtot * denom0)

        # Optimized Q and R weights
        Q = np.diag([4.5, 44.0, 0.6, 3.25])
        R = np.array([[1.0]])

        from scipy.linalg import solve_continuous_are
        P = solve_continuous_are(A, B, Q, R)
        K = np.linalg.inv(R) @ B.T @ P
        return K
    
    def _normalize_angle(self, theta):
        """Robust angle normalization using arctan2"""
        return np.arctan2(np.sin(theta), np.cos(theta))
    
    def _compute_phase_weights(self, abs_theta):
        """Compute smooth phase transition weights"""
        # Recovery weight: active above RECOVERY_THRESHOLD
        recovery_weight = 0.5 * (np.tanh(8.0 * (abs_theta - self.RECOVERY_THRESHOLD)) + 1.0)
        
        # Precision weight: active below PRECISION_THRESHOLD
        precision_weight = 0.5 * (np.tanh(12.0 * (self.PRECISION_THRESHOLD - abs_theta)) + 1.0)
        
        # Transition weight: fills the gap
        transition_weight = 1.0 - recovery_weight - precision_weight
        transition_weight = max(0.0, transition_weight)
        
        return recovery_weight, transition_weight, precision_weight
    
    def _recovery_force(self, theta, dtheta, base_force):
        """Recovery phase: aggressive swing-up assist"""
        abs_theta = abs(theta)
        
        # Strong adaptive gain for large deviations
        pos_gain = 1.0 + 0.55 * np.tanh(5.0 * max(0.0, abs_theta - 0.5))
        vel_gain = 1.0 + 0.35 * np.tanh(4.0 * max(0.0, abs(dtheta) - 0.8))
        adaptive_gain = pos_gain * vel_gain
        
        force = base_force * adaptive_gain
        
        # Energy-based swing-up assist
        if abs_theta > 0.75:
            swing_activation = np.tanh(6.0 * (abs_theta - 0.75))
            angular_momentum = theta * dtheta
            normalized_severity = angular_momentum / (L_COM * self.omega_n)
            falling_severity = 1.0 + np.tanh(3.0 * normalized_severity)
            u_swing = 9.0 * swing_activation * np.sign(theta) * falling_severity
            force = force + u_swing
        
        return force
    
    def _transition_force(self, theta, dtheta, base_force):
        """Transition phase: balanced control"""
        abs_theta = abs(theta)
        
        # Moderate adaptive gain
        pos_gain = 1.0 + 0.4 * np.tanh(5.0 * max(0.0, abs_theta - 0.4))
        vel_gain = 1.0 + 0.25 * np.tanh(4.0 * max(0.0, abs(dtheta) - 1.0))
        adaptive_gain = pos_gain * vel_gain
        
        return base_force * adaptive_gain
    
    def _precision_force(self, x, theta, dx, dtheta, base_force):
        """Precision phase: pure LQR with integral action for cart centering"""
        # Update integral only when pole is nearly upright
        if abs(theta) < self.PRECISION_THRESHOLD:
            # Anti-windup: limit integral accumulation
            self.x_integral = np.clip(self.x_integral + x * DT, -1.0, 1.0)
        else:
            # Decay integral when not in precision phase
            self.x_integral *= 0.98
        
        # Integral correction gated by upright proximity
        upright_gate = 0.5 * (np.tanh(15.0 * (self.PRECISION_THRESHOLD - abs(theta))) + 1.0)
        integral_correction = -self.integral_gain * self.x_integral * upright_gate
        
        return base_force + integral_correction
    
    def get_action(self, state):
        """Main control action with phase-based architecture"""
        x, theta, dx, dtheta = state
        
        # Normalize angle
        theta = self._normalize_angle(theta)
        abs_theta = abs(theta)
        
        # Compute base LQR force
        state_vec = np.array([x, theta, dx, dtheta])
        base_force = float((-self.K @ state_vec)[0])
        
        # Get phase weights
        w_recovery, w_transition, w_precision = self._compute_phase_weights(abs_theta)
        
        # Compute phase-specific forces
        f_recovery = self._recovery_force(theta, dtheta, base_force)
        f_transition = self._transition_force(theta, dtheta, base_force)
        f_precision = self._precision_force(x, theta, dx, dtheta, base_force)
        
        # Blend forces based on phase weights
        force = (w_recovery * f_recovery + 
                 w_transition * f_transition + 
                 w_precision * f_precision)
        
        return force


# Initialize controller
controller = PhaseBasedController()

def get_control_action(state):
    force = controller.get_action(state)
    return float(np.clip(force, -100.0, 100.0))
# EVOLVE-BLOCK-END

def run_simulation(seed=None):
    """
    Runs the simulation loop.
    """
    if seed is not None:
        np.random.seed(seed)

    state = np.array([0.0, 0.9, 0.0, 0.0])

    states = [state]
    forces = []

    for _ in range(MAX_STEPS):
        force = get_control_action(state)
        force = np.clip(force, -100.0, 100.0)

        next_state = simulate_pendulum_step(state, force, DT)

        states.append(next_state)
        forces.append(force)

        state = next_state

    return np.array(states), np.array(forces)
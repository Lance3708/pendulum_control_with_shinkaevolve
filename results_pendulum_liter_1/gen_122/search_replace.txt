Looking at the performance data, I notice our current program is consistently achieving around 4920 points with stabilization time of 192 steps. The best performers (4920.25) use additional features like swing-up assist and integral control that we're missing. Let me implement these proven enhancements while maintaining our solid foundation.

<NAME>
add_swing_up_assist_and_integral_control
</NAME>

<DESCRIPTION>
The current program lacks two key features present in the top-performing controllers: swing-up assist for large angles and integral control for cart position. The best program (4920.25) uses physics-informed swing-up assistance when angles exceed 0.8 rad, plus soft-switched integral action to eliminate steady-state position error.

This change adds:
1. Swing-up assist using normalized angular momentum for physical consistency
2. Soft-switched integral control with anti-windup protection
3. Natural frequency calculation for proper normalization
4. Leaky integration to prevent integral windup during large deviations
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def __init__(self):
        # System parameters
        m = M_POLE
        M = M_CART
        l = L_COM
        g = G
        Mtot = M + m
        denom0 = l * (4.0 / 3.0 - m / Mtot)
        b_c = FRICTION_CART
        b_j = FRICTION_JOINT

        # Physically accurate linearized A matrix with corrected joint friction
        A = np.zeros((4, 4))
        A[0, 2] = 1.0
        A[1, 3] = 1.0

        # theta_acc row (3) - using corrected joint friction term matching simulator
        A[3, 1] = g / denom0
        A[3, 2] = b_c / (Mtot * denom0)
        A[3, 3] = -b_j / (m * l * denom0)  # Matches simulator: f_joint/(m*l) / denom0

        # x_acc row (2)
        A[2, 1] = -(m * l / Mtot) * A[3, 1]
        A[2, 2] = -b_c / Mtot - (m * l / Mtot) * A[3, 2]
        A[2, 3] = b_j / (Mtot * denom0)

        # B matrix
        B = np.zeros((4, 1))
        B[2, 0] = 1.0 / Mtot + (m * l) / (Mtot**2 * denom0)
        B[3, 0] = -1.0 / (Mtot * denom0)

        # Optimized LQR weights: proven configuration from best performer (4920.14)
        Q = np.diag([4.5, 44.0, 0.6, 3.2])  # Restored best-performing weights
        R = np.array([[1.0]])

        # Solve LQR gains
        self.K = self.solve_lqr(A, B, Q, R)
=======
    def __init__(self):
        # System parameters
        m = M_POLE
        M = M_CART
        l = L_COM
        g = G
        Mtot = M + m
        denom0 = l * (4.0 / 3.0 - m / Mtot)
        b_c = FRICTION_CART
        b_j = FRICTION_JOINT

        # Physically accurate linearized A matrix with corrected joint friction
        A = np.zeros((4, 4))
        A[0, 2] = 1.0
        A[1, 3] = 1.0

        # theta_acc row (3) - using corrected joint friction term matching simulator
        A[3, 1] = g / denom0
        A[3, 2] = b_c / (Mtot * denom0)
        A[3, 3] = -b_j / (m * l * denom0)  # Matches simulator: f_joint/(m*l) / denom0

        # x_acc row (2)
        A[2, 1] = -(m * l / Mtot) * A[3, 1]
        A[2, 2] = -b_c / Mtot - (m * l / Mtot) * A[3, 2]
        A[2, 3] = b_j / (Mtot * denom0)

        # B matrix
        B = np.zeros((4, 1))
        B[2, 0] = 1.0 / Mtot + (m * l) / (Mtot**2 * denom0)
        B[3, 0] = -1.0 / (Mtot * denom0)

        # Optimized LQR weights: proven configuration from best performer (4920.14)
        Q = np.diag([4.5, 44.0, 0.6, 3.2])  # Restored best-performing weights
        R = np.array([[1.0]])

        # Solve LQR gains
        self.K = self.solve_lqr(A, B, Q, R)

        # Natural frequency for normalized falling severity
        self.omega_n = np.sqrt(G / L_COM)

        # Integral control for cart position
        self.integral_x = 0.0
        self.K_i = 0.05
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def get_action(self, state):
        """Adaptive LQR control with optimized gain scheduling"""
        x, theta, dx, dtheta = state

        # Normalize angle to [-pi, pi] with numerical safety
        theta = ((theta + np.pi + 1e-8) % (2 * np.pi)) - np.pi

        state_vec = np.array([x, theta, dx, dtheta])
        base_force = -self.K @ state_vec

        # Optimized gain scheduling: more aggressive for large errors
        # Position-based gain: sharp response beyond 0.6 rad
        pos_gain = 1.0 + 0.5 * np.tanh(5.0 * max(0.0, abs(theta) - 0.6))

        # Velocity-based gain: strong damping for high angular velocity
        vel_gain = 1.0 + 0.3 * np.tanh(4.0 * max(0.0, abs(dtheta) - 1.0))

        # Combined multiplicative gain (simpler and more effective)
        adaptive_gain = pos_gain * vel_gain

        force = base_force * adaptive_gain

        return float(force[0])
=======
    def get_action(self, state):
        """Adaptive LQR control with swing-up assist and integral control"""
        x, theta, dx, dtheta = state

        # Robust angle normalization using arctan2
        theta = np.arctan2(np.sin(theta), np.cos(theta))

        state_vec = np.array([x, theta, dx, dtheta])
        base_force = -self.K @ state_vec

        # Smooth gain scheduling using tanh activation
        pos_gain = 1.0 + 0.5 * np.tanh(5.0 * max(0.0, abs(theta) - 0.6))
        vel_gain = 1.0 + 0.3 * np.tanh(4.0 * max(0.0, abs(dtheta) - 1.0))

        # Combined multiplicative gain
        adaptive_gain = pos_gain * vel_gain
        force = base_force * adaptive_gain

        # Physics-informed swing-up assist for large angles (>0.8 rad)
        if abs(theta) > 0.8:
            # Normalized divergence metric: angular momentum scaled by natural frequency
            norm_momentum = (theta * dtheta) / (self.omega_n * L_COM)
            # Smooth activation based on angle deviation
            swing_activation = np.tanh(6.0 * (abs(theta) - 0.8))
            # Continuous falling severity: tanh for differentiable divergence scaling
            falling_severity = 1.0 + np.tanh(3.0 * norm_momentum)
            # Additive assist force
            u_swing = 8.0 * swing_activation * np.sign(theta) * falling_severity
            force += u_swing

        # Soft-switched integral action: activates only when nearly upright
        gate = np.tanh(12.0 * (0.1 - abs(theta)))
        self.integral_x += x * DT * gate
        # Leaky integration to prevent windup
        self.integral_x *= 0.95
        self.integral_x = np.clip(self.integral_x, -0.5, 0.5)
        force -= self.K_i * self.integral_x * gate

        return float(force[0])
>>>>>>> REPLACE
</DIFF>
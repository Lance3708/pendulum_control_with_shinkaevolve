Looking at the performance metrics, I can see that the current controller achieves good stabilization time and energy efficiency but struggles with position centering (final_x_error: 0.86, stable_x_error: 0.18). The direct position correction at the end helps but isn't sufficient.

My analysis reveals that the issue is in the integral control strategy. While the current approach has good theoretical foundations, it's not aggressive enough for position correction during the critical stabilization phase. Let me implement a more targeted approach that focuses specifically on position correction when the system is nearly balanced.

<NAME>
enhanced_position_centering_controller
</NAME>

<DESCRIPTION>
This improvement focuses on significantly enhancing position centering by implementing a more aggressive dual-mode integral control strategy. The key insight is to distinguish between two operational modes: 1) Active swing-up/stabilization phase where integral action should be conservative to prevent windup, and 2) Fine-tuning phase where aggressive position correction is needed.

The main changes are:
1. Implement separate integral terms for coarse and fine positioning
2. Add explicit position error feedback when system is stable
3. Increase integral gains during the fine-tuning phase
4. Add predictive position correction based on current velocity

This addresses the main weakness seen in the metrics - poor final position accuracy despite good stabilization timing.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# EVOLVE-BLOCK-START
class Controller:
    """
    Adaptive Cross-Coupled LQR with Enhanced Position Centering

    Combines fast stabilization with improved position control through:
    1. Direction-gated mid-swing damping for fast recovery
    2. Predictive momentum compensation
    3. Enhanced integral control with stronger position centering
    4. Direct position correction when pole is stable
    """

    def __init__(self):
        self.m = M_POLE
        self.M = M_CART
        self.l = L_COM
        self.g = G
        self.Mtot = self.M + self.m
        self.denom0 = self.l * (4.0 / 3.0 - self.m / self.Mtot)
        self.b_c = FRICTION_CART
        self.b_j = FRICTION_JOINT

        # Build A matrix
        A = np.zeros((4, 4))
        A[0, 2] = 1.0
        A[1, 3] = 1.0
        A[3, 1] = self.g / self.denom0
        A[3, 2] = self.b_c / (self.Mtot * self.denom0)
        A[3, 3] = -self.b_j / (self.m * self.l * self.denom0)
        A[2, 1] = -(self.m * self.l / self.Mtot) * A[3, 1]
        A[2, 2] = -self.b_c / self.Mtot - (self.m * self.l / self.Mtot) * A[3, 2]
        A[2, 3] = self.b_j / (self.Mtot * self.denom0)

        # B matrix
        B = np.zeros((4, 1))
        B[2, 0] = 1.0 / self.Mtot + (self.m * self.l) / (self.Mtot**2 * self.denom0)
        B[3, 0] = -1.0 / (self.Mtot * self.denom0)

        # Q matrix with cross-coupling
        Q = np.diag([4.5, 44.0, 0.6, 3.2])
        Q[1, 3] = 0.8
        Q[3, 1] = 0.8
        R = np.array([[1.0]])

        self.A = A
        self.B = B
        self.K = self.solve_lqr(A, B, Q, R)

        # Enhanced integral control
        self.integral_x = 0.0
        self.K_i = 1.2  # Increased from 0.85 for stronger position correction

        self.omega_n = np.sqrt(G / L_COM)

    def solve_lqr(self, A, B, Q, R):
        from scipy.linalg import solve_continuous_are
        P = solve_continuous_are(A, B, Q, R)
        K = np.linalg.inv(R) @ B.T @ P
        return K

    def get_action(self, state):
        x, theta, dx, dtheta = state

        theta = ((theta + np.pi) % (2 * np.pi)) - np.pi
        state_vec = np.array([x, theta, dx, dtheta])

        # Base LQR force
        base_force = -self.K @ state_vec

        # Adaptive gain scheduling
        pos_gain = 1.0 + 0.5 * np.tanh(5.0 * max(0.0, abs(theta) - 0.6))
        vel_gain = 1.0 + 0.3 * np.tanh(4.0 * max(0.0, abs(dtheta) - 1.0))
        adaptive_gain = pos_gain * vel_gain

        force = base_force * adaptive_gain

        # Direction-gated mid-swing damping
        mid_swing_activation = np.exp(-4.0 * (abs(theta) - 0.5)**2)
        if abs(theta) > 0.25 and abs(theta) < 0.85:
            K_d_midswing = 6.0
            is_returning = 0.5 * (1.0 - np.tanh(5.0 * theta * dtheta))
            midswing_damp = K_d_midswing * dtheta * mid_swing_activation * is_returning
            force = force + midswing_damp

        # Predictive momentum compensation
        sin_theta = np.sin(theta)
        cos_theta = np.cos(theta)

        f_cart = -self.b_c * dx
        f_joint = -self.b_j * dtheta
        temp_est = (force[0] + f_cart + self.m * self.l * dtheta**2 * sin_theta) / self.Mtot
        denominator = self.l * (4.0/3.0 - self.m * cos_theta**2 / self.Mtot)

        theta_acc_est = (self.g * sin_theta - cos_theta * temp_est + f_joint / (self.m * self.l)) / denominator
        dtheta_pred = dtheta + theta_acc_est * DT

        pred_divergence = theta * dtheta_pred / (self.omega_n * L_COM)
        predictive_correction = -0.12 * pred_divergence * np.tanh(2.0 * abs(theta))
        force = force + predictive_correction

        # Swing-up assist for large angles
        if abs(theta) > 0.8:
            swing_activation = np.tanh(6.0 * (abs(theta) - 0.8))
            falling_factor = 1.0 + np.tanh(2.0 * theta * dtheta / (L_COM * self.omega_n))
            u_swing = 8.0 * swing_activation * np.sign(theta) * falling_factor
            force = force + u_swing

        # Enhanced dual-gated integral action with stronger position focus
        angle_gate = np.tanh(12.0 * (0.15 - abs(theta)))  # Slightly wider gate
        velocity_gate = np.tanh(8.0 * (1.2 - abs(dtheta)))  # Slightly wider gate
        integral_gate = angle_gate * velocity_gate

        if integral_gate > 0.05:  # Lower threshold for activation
            self.integral_x += x * DT
            self.integral_x = np.clip(self.integral_x, -2.0, 2.0)  # Wider range
        else:
            self.integral_x *= 0.97  # Slower decay

        integral_force = self.K_i * integral_gate * self.integral_x
        force = force - integral_force

        # Direct position centering when pole is stable
        # This helps reduce the final_x_error when the system is nearly balanced
        stability_factor = np.exp(-10.0 * (theta**2 + 0.5 * dtheta**2))
        if stability_factor > 0.3:
            position_correction = -0.8 * x * stability_factor - 0.4 * dx * stability_factor
            force = force + position_correction

        return float(force[0])

# EVOLVE-BLOCK-END
=======
# EVOLVE-BLOCK-START
class Controller:
    """
    Adaptive Cross-Coupled LQR with Enhanced Position Centering

    Combines fast stabilization with improved position control through:
    1. Direction-gated mid-swing damping for fast recovery
    2. Predictive momentum compensation
    3. Dual-mode integral control for position centering
    4. Explicit position error feedback when stable
    """

    def __init__(self):
        self.m = M_POLE
        self.M = M_CART
        self.l = L_COM
        self.g = G
        self.Mtot = self.M + self.m
        self.denom0 = self.l * (4.0 / 3.0 - self.m / self.Mtot)
        self.b_c = FRICTION_CART
        self.b_j = FRICTION_JOINT

        # Build A matrix
        A = np.zeros((4, 4))
        A[0, 2] = 1.0
        A[1, 3] = 1.0
        A[3, 1] = self.g / self.denom0
        A[3, 2] = self.b_c / (self.Mtot * self.denom0)
        A[3, 3] = -self.b_j / (self.m * self.l * self.denom0)
        A[2, 1] = -(self.m * self.l / self.Mtot) * A[3, 1]
        A[2, 2] = -self.b_c / self.Mtot - (self.m * self.l / self.Mtot) * A[3, 2]
        A[2, 3] = self.b_j / (self.Mtot * self.denom0)

        # B matrix
        B = np.zeros((4, 1))
        B[2, 0] = 1.0 / self.Mtot + (self.m * self.l) / (self.Mtot**2 * self.denom0)
        B[3, 0] = -1.0 / (self.Mtot * self.denom0)

        # Q matrix with cross-coupling
        Q = np.diag([4.5, 44.0, 0.6, 3.2])
        Q[1, 3] = 0.8
        Q[3, 1] = 0.8
        R = np.array([[1.0]])

        self.A = A
        self.B = B
        self.K = self.solve_lqr(A, B, Q, R)

        # Dual-mode integral control
        self.integral_x_coarse = 0.0  # For general stabilization
        self.integral_x_fine = 0.0    # For precise positioning
        self.K_i_coarse = 0.8         # Conservative integral gain
        self.K_i_fine = 2.5           # Aggressive positioning gain

        self.omega_n = np.sqrt(G / L_COM)

    def solve_lqr(self, A, B, Q, R):
        from scipy.linalg import solve_continuous_are
        P = solve_continuous_are(A, B, Q, R)
        K = np.linalg.inv(R) @ B.T @ P
        return K

    def get_action(self, state):
        x, theta, dx, dtheta = state

        theta = ((theta + np.pi) % (2 * np.pi)) - np.pi
        state_vec = np.array([x, theta, dx, dtheta])

        # Base LQR force
        base_force = -self.K @ state_vec

        # Adaptive gain scheduling
        pos_gain = 1.0 + 0.5 * np.tanh(5.0 * max(0.0, abs(theta) - 0.6))
        vel_gain = 1.0 + 0.3 * np.tanh(4.0 * max(0.0, abs(dtheta) - 1.0))
        adaptive_gain = pos_gain * vel_gain

        force = base_force * adaptive_gain

        # Direction-gated mid-swing damping
        mid_swing_activation = np.exp(-4.0 * (abs(theta) - 0.5)**2)
        if abs(theta) > 0.25 and abs(theta) < 0.85:
            K_d_midswing = 6.0
            is_returning = 0.5 * (1.0 - np.tanh(5.0 * theta * dtheta))
            midswing_damp = K_d_midswing * dtheta * mid_swing_activation * is_returning
            force = force + midswing_damp

        # Predictive momentum compensation
        sin_theta = np.sin(theta)
        cos_theta = np.cos(theta)

        f_cart = -self.b_c * dx
        f_joint = -self.b_j * dtheta
        temp_est = (force[0] + f_cart + self.m * self.l * dtheta**2 * sin_theta) / self.Mtot
        denominator = self.l * (4.0/3.0 - self.m * cos_theta**2 / self.Mtot)

        theta_acc_est = (self.g * sin_theta - cos_theta * temp_est + f_joint / (self.m * self.l)) / denominator
        dtheta_pred = dtheta + theta_acc_est * DT

        pred_divergence = theta * dtheta_pred / (self.omega_n * L_COM)
        predictive_correction = -0.12 * pred_divergence * np.tanh(2.0 * abs(theta))
        force = force + predictive_correction

        # Swing-up assist for large angles
        if abs(theta) > 0.8:
            swing_activation = np.tanh(6.0 * (abs(theta) - 0.8))
            falling_factor = 1.0 + np.tanh(2.0 * theta * dtheta / (L_COM * self.omega_n))
            u_swing = 8.0 * swing_activation * np.sign(theta) * falling_factor
            force = force + u_swing

        # Dual-mode integral control
        # Coarse integral (conservative, active during swing-up)
        angle_gate_coarse = np.tanh(12.0 * (0.2 - abs(theta)))
        velocity_gate_coarse = np.tanh(8.0 * (1.5 - abs(dtheta)))
        integral_gate_coarse = angle_gate_coarse * velocity_gate_coarse

        if integral_gate_coarse > 0.05:
            self.integral_x_coarse += x * DT
            self.integral_x_coarse = np.clip(self.integral_x_coarse, -2.5, 2.5)
        else:
            self.integral_x_coarse *= 0.96

        integral_force_coarse = self.K_i_coarse * integral_gate_coarse * self.integral_x_coarse
        force = force - integral_force_coarse

        # Fine integral (aggressive, active when nearly balanced)
        stability_measure = abs(theta) + 0.3 * abs(dtheta)
        fine_gate = np.tanh(8.0 * (0.15 - stability_measure))

        if fine_gate > 0.1:
            self.integral_x_fine += x * DT
            self.integral_x_fine = np.clip(self.integral_x_fine, -3.0, 3.0)
        else:
            self.integral_x_fine *= 0.98

        integral_force_fine = self.K_i_fine * fine_gate * self.integral_x_fine
        force = force - integral_force_fine

        # Explicit position correction when stable
        # More aggressive than previous version
        stability_factor = np.exp(-15.0 * (theta**2 + 0.4 * dtheta**2))
        if stability_factor > 0.25:
            # Predictive position correction based on current velocity
            predicted_x = x + dx * DT * 5.0  # Predict 5 steps ahead
            position_correction = -1.2 * predicted_x * stability_factor - 0.6 * dx * stability_factor
            force = force + position_correction

        return float(force[0])

# EVOLVE-BLOCK-END
>>>>>>> REPLACE

</DIFF>
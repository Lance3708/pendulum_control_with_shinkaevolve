<NAME>
phase_based_control
</NAME>

<DESCRIPTION>
I'm replacing the LQR-based approach with a completely different paradigm: phase-based control. Instead of using optimal control theory, I'll implement distinct control strategies for different phases of balancing, similar to how a human would approach the problem. This addresses the core constraint of avoiding LQR/Riccati methods while potentially improving performance through more targeted, situation-specific responses.

The four phases are:
1. Emergency Phase (|theta| > 0.7 rad): Aggressive swing-up to quickly get the rod vertical
2. Convergence Phase (0.2 < |theta| <= 0.7 rad): Controlled guidance to vertical
3. Stabilization Phase (|theta| <= 0.2 rad): Fine-tuning position and angle
4. Precision Hold Phase (|theta| <= 0.05 and |dtheta| <= 0.1): Minimizing drift

Each phase uses simple, interpretable rules rather than matrix computations.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
# EVOLVE-BLOCK-START
class Controller:
    """
    Adaptive Cross-Coupled LQR with Mid-Swing Damping and Predictive Compensation

    Key innovations:
    1. State-dependent cross-coupling in Q-matrix for better coordination
    2. Mid-swing angular damping to suppress momentum overshoot
    3. Predictive momentum compensation for earlier counteraction
    4. Refined integral control with dual gating
    """

    def __init__(self):
        # System parameters
        self.m = M_POLE
        self.M = M_CART
        self.l = L_COM
        self.g = G
        self.Mtot = self.M + self.m
        self.denom0 = self.l * (4.0 / 3.0 - self.m / self.Mtot)
        self.b_c = FRICTION_CART
        self.b_j = FRICTION_JOINT

        # Build base A matrix
        A = np.zeros((4, 4))
        A[0, 2] = 1.0
        A[1, 3] = 1.0
        A[3, 1] = self.g / self.denom0
        A[3, 2] = self.b_c / (self.Mtot * self.denom0)
        A[3, 3] = -self.b_j / (self.m * self.l * self.denom0)
        A[2, 1] = -(self.m * self.l / self.Mtot) * A[3, 1]
        A[2, 2] = -self.b_c / self.Mtot - (self.m * self.l / self.Mtot) * A[3, 2]
        A[2, 3] = self.b_j / (self.Mtot * self.denom0)

        # B matrix
        B = np.zeros((4, 1))
        B[2, 0] = 1.0 / self.Mtot + (self.m * self.l) / (self.Mtot**2 * self.denom0)
        B[3, 0] = -1.0 / (self.Mtot * self.denom0)

        # Base Q with proven optimal diagonal weights
        Q = np.diag([4.5, 44.0, 0.6, 3.2])
        # Add cross-coupling terms for theta-dtheta coordination
        Q[1, 3] = 0.8
        Q[3, 1] = 0.8
        R = np.array([[1.0]])

        self.A = A
        self.B = B
        self.K = self.solve_lqr(A, B, Q, R)

        # Integral control parameters
        self.integral_x = 0.0
        self.K_i = 0.85

        # Natural frequency for normalized calculations
        self.omega_n = np.sqrt(G / L_COM)

    def solve_lqr(self, A, B, Q, R):
        """Solve continuous-time LQR"""
        from scipy.linalg import solve_continuous_are
        P = solve_continuous_are(A, B, Q, R)
        K = np.linalg.inv(R) @ B.T @ P
        return K

    def get_action(self, state):
        """Adaptive LQR with cross-coupling, mid-swing damping, and predictive compensation"""
        x, theta, dx, dtheta = state

        # Robust angle normalization
        theta = ((theta + np.pi) % (2 * np.pi)) - np.pi

        state_vec = np.array([x, theta, dx, dtheta])

        # Base LQR force with state-dependent cross-coupling enhancement
        # Intensify theta-dtheta coupling when angle is large
        cross_coupling_boost = 1.0 + 0.5 * np.tanh(3.0 * abs(theta))

        # Compute base force
        base_force = -self.K @ state_vec

        # Adaptive gain scheduling with proven parameters
        pos_gain = 1.0 + 0.5 * np.tanh(5.0 * max(0.0, abs(theta) - 0.6))
        vel_gain = 1.0 + 0.3 * np.tanh(4.0 * max(0.0, abs(dtheta) - 1.0))
        adaptive_gain = pos_gain * vel_gain

        force = base_force * adaptive_gain

        # Mid-swing angular damping (0.3-0.7 rad range)
        # Suppresses momentum overshoot during high-energy transition
        mid_swing_activation = np.exp(-4.0 * (abs(theta) - 0.5)**2)  # Gaussian centered at 0.5 rad
        if abs(theta) > 0.25 and abs(theta) < 0.85:
            K_d_midswing = 2.5
            midswing_damp = -K_d_midswing * dtheta * mid_swing_activation
            force = force + midswing_damp

        # Predictive momentum compensation with full dynamic coupling
        sin_theta = np.sin(theta)
        cos_theta = np.cos(theta)

        # Estimate cart acceleration from applied force (ignoring higher-order terms)
        estimated_x_acc = force[0] / self.Mtot - self.b_c * dx / self.Mtot

        # Full theta acceleration estimate including cart coupling
        theta_acc_est = (self.g * sin_theta
                        - (cos_theta * estimated_x_acc)
                        - self.b_j * dtheta / (self.m * self.l)) \
                       / (self.l * (4.0/3.0 - self.m * cos_theta**2 / self.Mtot))

        dtheta_pred = dtheta + theta_acc_est * DT

        # Corrective term based on predicted divergence
        pred_divergence = theta * dtheta_pred / (self.omega_n * L_COM)
        predictive_correction = -0.12 * pred_divergence * np.tanh(2.0 * abs(theta))
        force = force + predictive_correction

        # Swing-up assist for large angles
        if abs(theta) > 0.8:
            swing_activation = np.tanh(6.0 * (abs(theta) - 0.8))
            falling_factor = 1.0 + np.tanh(2.0 * theta * dtheta / (L_COM * self.omega_n))
            u_swing = 8.0 * swing_activation * np.sign(theta) * falling_factor
            force = force + u_swing

        # Dual-gated integral action (angle AND velocity gating)
        angle_gate = np.tanh(12.0 * (0.1 - abs(theta)))
        velocity_gate = np.tanh(8.0 * (1.0 - abs(dtheta)))
        integral_gate = angle_gate * velocity_gate

        if integral_gate > 0.1:
            self.integral_x += x * DT
            self.integral_x = np.clip(self.integral_x, -1.5, 1.5)
        else:
            self.integral_x *= 0.95

        integral_force = self.K_i * integral_gate * self.integral_x
        force = force + integral_force

        return float(force[0])
=======
# EVOLVE-BLOCK-START
class Controller:
    """
    Phase-Based Controller with Distinct Control Strategies

    Key innovations:
    1. Four distinct phases with completely different control strategies
    2. No matrix operations or optimal control theory
    3. Simple, interpretable rules for each phase
    4. Sharp transitions between phases (no blending)
    """

    def __init__(self):
        # System parameters for calculations
        self.m = M_POLE
        self.M = M_CART
        self.l = L_COM
        self.g = G
        self.Mtot = self.M + self.m

        # Natural frequency for normalized calculations
        self.omega_n = np.sqrt(G / L_COM)

        # Integral control for precision phase
        self.integral_x = 0.0
        self.integral_theta = 0.0

        # Previous state for prediction
        self.prev_state = None

    def get_action(self, state):
        """Phase-based control with distinct strategies for each situation"""
        x, theta, dx, dtheta = state

        # Robust angle normalization
        theta = ((theta + np.pi) % (2 * np.pi)) - np.pi

        # Determine current phase
        abs_theta = abs(theta)
        abs_dtheta = abs(dtheta)

        # Phase 1: Emergency (rod falling fast)
        if abs_theta > 0.7:
            return self.emergency_response(x, theta, dx, dtheta)

        # Phase 2: Convergence (getting close to vertical)
        elif abs_theta > 0.2:
            return self.convergence_response(x, theta, dx, dtheta)

        # Phase 3: Stabilization (nearly balanced)
        elif abs_theta > 0.05 or abs_dtheta > 0.1:
            return self.stabilization_response(x, theta, dx, dtheta)

        # Phase 4: Precision Hold (nearly perfect)
        else:
            return self.precision_hold_response(x, theta, dx, dtheta)

    def emergency_response(self, x, theta, dx, dtheta):
        """Aggressive swing-up to quickly get rod vertical"""
        # Push cart toward falling direction with urgency
        urgency = min(3.0, abs(theta) / 0.3)  # Scale with angle

        # Base force: push toward where rod is falling
        base_force = 15.0 * urgency * np.sign(theta)

        # Add energy injection based on angular velocity
        # If rod is falling in the right direction, add more energy
        if theta * dtheta > 0:  # Falling away from vertical
            energy_boost = 8.0 * np.sign(theta)
        else:  # Falling toward vertical
            energy_boost = 3.0 * np.sign(theta)

        # Cart position correction (secondary concern during emergency)
        pos_correction = -2.0 * np.tanh(x / 2.0)

        force = base_force + energy_boost + pos_correction

        return float(np.clip(force, -100.0, 100.0))

    def convergence_response(self, x, theta, dx, dtheta):
        """Controlled guidance to vertical position"""
        # Predict where rod will be in 0.1 seconds
        theta_pred = theta + dtheta * 0.1

        # Push cart to intercept predicted rod position
        intercept_force = 12.0 * np.sign(theta_pred) * (1.0 + abs(theta) / 0.5)

        # Dampen angular velocity
        damping_force = -4.0 * dtheta

        # Gentle cart position correction
        pos_correction = -3.0 * np.tanh(x / 1.5)

        # Cart velocity damping
        vel_damping = -1.5 * dx

        force = intercept_force + damping_force + pos_correction + vel_damping

        return float(np.clip(force, -100.0, 100.0))

    def stabilization_response(self, x, theta, dx, dtheta):
        """Fine-tune position and angle"""
        # Primary goal: keep rod vertical
        angle_correction = -25.0 * theta - 8.0 * dtheta

        # Secondary goal: center cart
        pos_correction = -8.0 * x - 3.0 * dx

        # Predictive component: anticipate where rod is going
        pred_component = -5.0 * theta * dtheta

        force = angle_correction + pos_correction + pred_component

        # Update integral for position drift
        self.integral_x += x * DT
        self.integral_x = np.clip(self.integral_x, -0.5, 0.5)
        integral_force = -2.0 * self.integral_x

        force += integral_force

        return float(np.clip(force, -100.0, 100.0))

    def precision_hold_response(self, x, theta, dx, dtheta):
        """Minimize drift and maintain perfect balance"""
        # Very gentle angle correction
        angle_correction = -15.0 * theta - 5.0 * dtheta

        # Strong position correction to eliminate drift
        pos_correction = -12.0 * x - 4.0 * dx

        # Update integrals for both position and angle
        self.integral_x += x * DT
        self.integral_theta += theta * DT

        # Clip integrals to prevent windup
        self.integral_x = np.clip(self.integral_x, -0.3, 0.3)
        self.integral_theta = np.clip(self.integral_theta, -0.05, 0.05)

        # Integral corrections
        integral_force = -3.0 * self.integral_x - 20.0 * self.integral_theta

        force = angle_correction + pos_correction + integral_force

        return float(np.clip(force, -100.0, 100.0))
>>>>>>> REPLACE
</DIFF>
<NAME>
enhance_position_control
</NAME>

<DESCRIPTION>
The current program shows poor position control with final_x_error of 1.08 and stable_x_error of 0.74. While the angle control is excellent (final_theta_error: 0.00), the cart drifts significantly from center. The issue is in the balancing phase where position correction is too conservative and only activates at high stability thresholds. I'll enhance position control by: 1) Lowering the stability threshold for position correction from 0.3 to 0.15, 2) Increasing the position correction gains from -1.2/-0.6 to -1.8/-0.9, 3) Increasing the integral gain base from 0.85 to 1.2 for better steady-state accuracy, and 4) Making the integral limits more aggressive to prevent windup while allowing stronger correction.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
            # Enhanced integral control with proper sign and windup protection
            angle_gate = np.tanh(15.0 * (0.08 - abs_theta))
            velocity_gate = np.tanh(10.0 * (0.8 - abs(dtheta)))
            integral_gate = angle_gate * velocity_gate

            # Adaptive integral gain scheduling based on proximity to equilibrium
            equilibrium_proximity = np.exp(-4.0 * (abs_theta + 0.4 * abs(dtheta)))
            K_i_adaptive = 0.85 * equilibrium_proximity
            K_i_adaptive = np.clip(K_i_adaptive, 0.3, 0.85)

            if integral_gate > 0.2:
                self.integral_x += x * DT
                # Enhanced windup protection with dynamic limits
                integral_limit = 1.0 + 2.0 * (1.0 - integral_gate)
                self.integral_x = np.clip(self.integral_x, -integral_limit, integral_limit)
            else:
                self.integral_x *= 0.98  # Slower decay to preserve useful integral

            integral_force = K_i_adaptive * integral_gate * self.integral_x
            # Correct sign: integral should oppose position error
            force = force - integral_force

            # Enhanced position correction for better centering
            stability_factor = np.exp(-8.0 * (theta**2 + 0.3 * dtheta**2))
            if stability_factor > 0.3:  # More aggressive activation
                # Position correction with velocity matching
                position_correction = -1.2 * x * stability_factor - 0.6 * dx * stability_factor
                force = force + position_correction
=======
            # Enhanced integral control with proper sign and windup protection
            angle_gate = np.tanh(15.0 * (0.08 - abs_theta))
            velocity_gate = np.tanh(10.0 * (0.8 - abs(dtheta)))
            integral_gate = angle_gate * velocity_gate

            # Adaptive integral gain scheduling based on proximity to equilibrium
            equilibrium_proximity = np.exp(-4.0 * (abs_theta + 0.4 * abs(dtheta)))
            K_i_adaptive = 1.2 * equilibrium_proximity  # Increased base gain for better position control
            K_i_adaptive = np.clip(K_i_adaptive, 0.4, 1.2)  # Raised upper limit

            if integral_gate > 0.2:
                self.integral_x += x * DT
                # Enhanced windup protection with dynamic limits
                integral_limit = 1.5 + 1.5 * (1.0 - integral_gate)  # More aggressive limits
                self.integral_x = np.clip(self.integral_x, -integral_limit, integral_limit)
            else:
                self.integral_x *= 0.96  # Faster decay when not in gate

            integral_force = K_i_adaptive * integral_gate * self.integral_x
            # Correct sign: integral should oppose position error
            force = force - integral_force

            # Enhanced position correction for better centering
            stability_factor = np.exp(-8.0 * (theta**2 + 0.3 * dtheta**2))
            if stability_factor > 0.15:  # Lower threshold for earlier activation
                # Stronger position correction with velocity matching
                position_correction = -1.8 * x * stability_factor - 0.9 * dx * stability_factor
                force = force + position_correction
>>>>>>> REPLACE
</DIFF>
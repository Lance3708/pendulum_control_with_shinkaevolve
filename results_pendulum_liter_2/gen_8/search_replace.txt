<NAME>
reflex_cascade_control
</NAME>

<DESCRIPTION>
Replacing the complex LQR/mathematical controller with a "Reflex Cascade" system (Challenge F / Challenge A).
The new design relies on distinct behavioral phases:
1. Panic Reflex: If the rod is unstable, max priority is given to angle correction using non-linear P-D logic.
2. Centering Reflex: Position control is only blended in when the rod is near-vertical (stability metric).
3. Friction Compensation: A static kick is added to overcome the high cart friction.
This removes all matrix operations and obscure math, replacing them with interpretable physics-based heuristics.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
class Controller:
    """
    Adaptive Cross-Coupled LQR with Mid-Swing Damping and Predictive Compensation

    Key innovations:
    1. State-dependent cross-coupling in Q-matrix for better coordination
    2. Mid-swing angular damping to suppress momentum overshoot
    3. Predictive momentum compensation for earlier counteraction
    4. Refined integral control with dual gating
    """

    def __init__(self):
        # System parameters
        self.m = M_POLE
        self.M = M_CART
        self.l = L_COM
        self.g = G
        self.Mtot = self.M + self.m
        self.denom0 = self.l * (4.0 / 3.0 - self.m / self.Mtot)
        self.b_c = FRICTION_CART
        self.b_j = FRICTION_JOINT

        # Build base A matrix
        A = np.zeros((4, 4))
        A[0, 2] = 1.0
        A[1, 3] = 1.0
        A[3, 1] = self.g / self.denom0
        A[3, 2] = self.b_c / (self.Mtot * self.denom0)
        A[3, 3] = -self.b_j / (self.m * self.l * self.denom0)
        A[2, 1] = -(self.m * self.l / self.Mtot) * A[3, 1]
        A[2, 2] = -self.b_c / self.Mtot - (self.m * self.l / self.Mtot) * A[3, 2]
        A[2, 3] = self.b_j / (self.Mtot * self.denom0)

        # B matrix
        B = np.zeros((4, 1))
        B[2, 0] = 1.0 / self.Mtot + (self.m * self.l) / (self.Mtot**2 * self.denom0)
        B[3, 0] = -1.0 / (self.Mtot * self.denom0)

        # Base Q with proven optimal diagonal weights
        Q = np.diag([4.5, 44.0, 0.6, 3.2])
        # Add cross-coupling terms for theta-dtheta coordination
        Q[1, 3] = 0.8
        Q[3, 1] = 0.8
        R = np.array([[1.0]])

        self.A = A
        self.B = B
        self.K = self.solve_lqr(A, B, Q, R)

        # Integral control parameters
        self.integral_x = 0.0
        self.K_i = 0.85

        # Natural frequency for normalized calculations
        self.omega_n = np.sqrt(G / L_COM)

    def solve_lqr(self, A, B, Q, R):
        """Solve continuous-time LQR"""
        from scipy.linalg import solve_continuous_are
        P = solve_continuous_are(A, B, Q, R)
        K = np.linalg.inv(R) @ B.T @ P
        return K

    def get_action(self, state):
        """Adaptive LQR with cross-coupling, mid-swing damping, and predictive compensation"""
        x, theta, dx, dtheta = state

        # Robust angle normalization
        theta = ((theta + np.pi) % (2 * np.pi)) - np.pi

        state_vec = np.array([x, theta, dx, dtheta])

        # Base LQR force with state-dependent cross-coupling enhancement
        # Intensify theta-dtheta coupling when angle is large
        cross_coupling_boost = 1.0 + 0.5 * np.tanh(3.0 * abs(theta))

        # Compute base force
        base_force = -self.K @ state_vec

        # Adaptive gain scheduling with proven parameters
        pos_gain = 1.0 + 0.5 * np.tanh(5.0 * max(0.0, abs(theta) - 0.6))
        vel_gain = 1.0 + 0.3 * np.tanh(4.0 * max(0.0, abs(dtheta) - 1.0))
        adaptive_gain = pos_gain * vel_gain

        force = base_force * adaptive_gain

        # Mid-swing angular damping (0.3-0.7 rad range)
        # Suppresses momentum overshoot during high-energy transition
        mid_swing_activation = np.exp(-4.0 * (abs(theta) - 0.5)**2)  # Gaussian centered at 0.5 rad
        if abs(theta) > 0.25 and abs(theta) < 0.85:
            K_d_midswing = 2.5
            midswing_damp = -K_d_midswing * dtheta * mid_swing_activation
            force = force + midswing_damp

        # Predictive momentum compensation
        # Estimate angular acceleration and extrapolate dtheta
        sin_theta = np.sin(theta)
        cos_theta = np.cos(theta)

        # Simplified theta acceleration estimate (gravity-dominated)
        theta_acc_est = (self.g * sin_theta - self.b_j * dtheta / (self.m * self.l)) / \
                        (self.l * (4.0/3.0 - self.m * cos_theta**2 / self.Mtot))

        dtheta_pred = dtheta + theta_acc_est * DT

        # Corrective term based on predicted divergence
        pred_divergence = theta * dtheta_pred / (self.omega_n * L_COM)
        predictive_correction = -0.12 * pred_divergence * np.tanh(2.0 * abs(theta))
        force = force + predictive_correction

        # Swing-up assist for large angles
        if abs(theta) > 0.8:
            swing_activation = np.tanh(6.0 * (abs(theta) - 0.8))
            falling_factor = 1.0 + np.tanh(2.0 * theta * dtheta / (L_COM * self.omega_n))
            u_swing = 8.0 * swing_activation * np.sign(theta) * falling_factor
            force = force + u_swing

        # Dual-gated integral action (angle AND velocity gating)
        angle_gate = np.tanh(12.0 * (0.1 - abs(theta)))
        velocity_gate = np.tanh(8.0 * (1.0 - abs(dtheta)))
        integral_gate = angle_gate * velocity_gate

        if integral_gate > 0.1:
            self.integral_x += x * DT
            self.integral_x = np.clip(self.integral_x, -1.5, 1.5)
        else:
            self.integral_x *= 0.95

        integral_force = self.K_i * integral_gate * self.integral_x
        force = force + integral_force

        return float(force[0])
=======
class Controller:
    """
    Reflex Cascade Controller (Challenge F + A)

    Philosophy:
    Instead of solving equations, we implement a hierarchy of biological-style reflexes.
    1. SURVIVAL (High Priority): If rod is falling, generate strong force to catch it.
       Ignore position.
    2. BALANCE (Medium Priority): If rod is safe, guide it to vertical with damping.
    3. CENTERING (Low Priority): If balanced, gently nudge cart to 0.

    Physics-aware adjustments:
    - High-friction compensation: Static boost to overcome stickiness.
    - Long-pole inertia handling: Strong angular velocity feedback.
    """

    def __init__(self):
        # Heuristic Gains (No matrix math)
        # Tuned for M_POLE=0.35, L_POLE=2.5 (High inertia)
        self.Kp_ang = 105.0
        self.Kd_ang = 42.0

        self.Kp_pos = 3.5
        self.Kd_pos = 7.0

        self.integ_x = 0.0

    def get_action(self, state):
        x, theta, dx, dtheta = state

        # 1. Assess Urgency (The "Phase")
        # How close are we to failure?
        # Combined metric of angle and angular speed
        urgency = abs(theta) + 0.4 * abs(dtheta)

        # Stability score: 1.0 = perfect, 0.0 = chaos
        # Used to blend between "Survival" and "Precision" modes
        stability = max(0.0, 1.0 - 2.5 * urgency)

        # 2. Survival Reflex (Rod Control)
        # Push cart to get under the rod.
        # Nonlinear boost: If falling fast/far, react disproportionately stronger
        panic_boost = 1.0 + 2.0 * urgency**2
        rod_force = panic_boost * (self.Kp_ang * theta + self.Kd_ang * dtheta)

        # 3. Centering Reflex (Cart Control)
        # Push cart to x=0.
        # Negated because x>0 requires Force<0 to return.
        # Integral term leaks away if unstable to prevent windup during recovery
        if stability > 0.6:
            self.integ_x += x * 0.02 # DT is 0.02
            self.integ_x = np.clip(self.integ_x, -3.0, 3.0)
        else:
            self.integ_x *= 0.92

        pos_force = -(self.Kp_pos * x + self.Kd_pos * dx + 1.5 * self.integ_x)

        # 4. Reflex Blending
        # As stability drops, position control is cut to focus on rod survival
        # Rod force is always active (it's the primary constraint)
        total_force = rod_force + pos_force * (stability**3)

        # 5. Friction Injection
        # The cart has high friction (0.35). Small forces do nothing.
        # If we command a force, ensure it's enough to actually slide the cart
        # or help overcome the drag.
        if abs(dx) < 0.2 and abs(total_force) > 0.5:
             # Add a "kick" in the direction of intended force
             total_force += 4.0 * np.sign(total_force)

        return float(total_force)
>>>>>>> REPLACE
</DIFF>
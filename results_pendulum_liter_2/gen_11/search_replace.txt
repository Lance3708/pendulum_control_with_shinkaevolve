<NAME>
simple_reactive_controller
</NAME>
<DESCRIPTION>
Replace the current LQR-based controller with a simple reactive controller that uses distinct modes for different situations. The new controller follows the philosophy: "Simple reactive rules with distinct modes: panic-save, swing-up, approach, and precise-hold".

This completely avoids LQR and matrix operations, instead using intuitive physics-based rules. The controller has four distinct modes:
1. Panic-save: When rod is falling dangerously (>0.7 rad)
2. Swing-up: When rod needs energy to reach upright (0.3-0.7 rad)
3. Approach: When rod is near vertical but not stable (0.1-0.3 rad or high angular velocity)
4. Precise-hold: When rod is nearly balanced (<0.1 rad and low angular velocity)

Each mode uses simple, interpretable control rules focused on energy efficiency and fast stabilization.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
class Controller:
    """
    Adaptive Cross-Coupled LQR with Mid-Swing Damping and Predictive Compensation

    Key innovations:
    1. State-dependent cross-coupling in Q-matrix for better coordination
    2. Mid-swing angular damping to suppress momentum overshoot
    3. Predictive momentum compensation for earlier counteraction
    4. Refined integral control with dual gating
    """

    def __init__(self):
        # System parameters
        self.m = M_POLE
        self.M = M_CART
        self.l = L_COM
        self.g = G
        self.Mtot = self.M + self.m
        self.denom0 = self.l * (4.0 / 3.0 - self.m / self.Mtot)
        self.b_c = FRICTION_CART
        self.b_j = FRICTION_JOINT

        # Build base A matrix
        A = np.zeros((4, 4))
        A[0, 2] = 1.0
        A[1, 3] = 1.0
        A[3, 1] = self.g / self.denom0
        A[3, 2] = self.b_c / (self.Mtot * self.denom0)
        A[3, 3] = -self.b_j / (self.m * self.l * self.denom0)
        A[2, 1] = -(self.m * self.l / self.Mtot) * A[3, 1]
        A[2, 2] = -self.b_c / self.Mtot - (self.m * self.l / self.Mtot) * A[3, 2]
        A[2, 3] = self.b_j / (self.Mtot * self.denom0)

        # B matrix
        B = np.zeros((4, 1))
        B[2, 0] = 1.0 / self.Mtot + (self.m * self.l) / (self.Mtot**2 * self.denom0)
        B[3, 0] = -1.0 / (self.Mtot * self.denom0)

        # Base Q with proven optimal diagonal weights
        Q = np.diag([4.5, 44.0, 0.6, 3.2])
        # Add cross-coupling terms for theta-dtheta coordination
        Q[1, 3] = 0.8
        Q[3, 1] = 0.8
        R = np.array([[1.0]])

        self.A = A
        self.B = B
        self.K = self.solve_lqr(A, B, Q, R)

        # Integral control parameters
        self.integral_x = 0.0
        self.K_i = 0.85

        # Natural frequency for normalized calculations
        self.omega_n = np.sqrt(G / L_COM)

    def solve_lqr(self, A, B, Q, R):
        """Solve continuous-time LQR"""
        from scipy.linalg import solve_continuous_are
        P = solve_continuous_are(A, B, Q, R)
        K = np.linalg.inv(R) @ B.T @ P
        return K

    def get_action(self, state):
        """Adaptive LQR with cross-coupling, mid-swing damping, and predictive compensation"""
        x, theta, dx, dtheta = state

        # Robust angle normalization
        theta = ((theta + np.pi) % (2 * np.pi)) - np.pi

        state_vec = np.array([x, theta, dx, dtheta])

        # Base LQR force with state-dependent cross-coupling enhancement
        # Intensify theta-dtheta coupling when angle is large
        cross_coupling_boost = 1.0 + 0.5 * np.tanh(3.0 * abs(theta))

        # Compute base force
        base_force = -self.K @ state_vec

        # Adaptive gain scheduling with proven parameters
        pos_gain = 1.0 + 0.5 * np.tanh(5.0 * max(0.0, abs(theta) - 0.6))
        vel_gain = 1.0 + 0.3 * np.tanh(4.0 * max(0.0, abs(dtheta) - 1.0))
        adaptive_gain = pos_gain * vel_gain

        force = base_force * adaptive_gain

        # Mid-swing angular damping (0.3-0.7 rad range)
        # Suppresses momentum overshoot during high-energy transition
        mid_swing_activation = np.exp(-4.0 * (abs(theta) - 0.5)**2)  # Gaussian centered at 0.5 rad
        if abs(theta) > 0.25 and abs(theta) < 0.85:
            K_d_midswing = 2.5
            midswing_damp = -K_d_midswing * dtheta * mid_swing_activation
            force = force + midswing_damp

        # Predictive momentum compensation
        # Estimate angular acceleration and extrapolate dtheta
        sin_theta = np.sin(theta)
        cos_theta = np.cos(theta)

        # Simplified theta acceleration estimate (gravity-dominated)
        theta_acc_est = (self.g * sin_theta - self.b_j * dtheta / (self.m * self.l)) / \
                        (self.l * (4.0/3.0 - self.m * cos_theta**2 / self.Mtot))

        dtheta_pred = dtheta + theta_acc_est * DT

        # Corrective term based on predicted divergence
        pred_divergence = theta * dtheta_pred / (self.omega_n * L_COM)
        predictive_correction = -0.12 * pred_divergence * np.tanh(2.0 * abs(theta))
        force = force + predictive_correction

        # Swing-up assist for large angles
        if abs(theta) > 0.8:
            swing_activation = np.tanh(6.0 * (abs(theta) - 0.8))
            falling_factor = 1.0 + np.tanh(2.0 * theta * dtheta / (L_COM * self.omega_n))
            u_swing = 8.0 * swing_activation * np.sign(theta) * falling_factor
            force = force + u_swing

        # Dual-gated integral action (angle AND velocity gating)
        angle_gate = np.tanh(12.0 * (0.1 - abs(theta)))
        velocity_gate = np.tanh(8.0 * (1.0 - abs(dtheta)))
        integral_gate = angle_gate * velocity_gate

        if integral_gate > 0.1:
            self.integral_x += x * DT
            self.integral_x = np.clip(self.integral_x, -1.5, 1.5)
        else:
            self.integral_x *= 0.95

        integral_force = self.K_i * integral_gate * self.integral_x
        force = force + integral_force

        return float(force[0])
=======
class Controller:
    """
    Simple Reactive Controller with Distinct Modes

    Philosophy: Simple reactive rules with distinct modes:
    1. Panic-save: When rod is falling dangerously
    2. Swing-up: When rod needs energy to reach upright
    3. Approach: When rod is near vertical but not stable
    4. Precise-hold: When rod is nearly balanced

    No LQR, no matrices, just intuitive physics responses.
    """

    def __init__(self):
        # System parameters for intuitive calculations
        self.m = M_POLE
        self.M = M_CART
        self.l = L_COM
        self.g = G

        # Natural frequency of pendulum
        self.omega_n = np.sqrt(G / L_COM)

        # Energy reference for upright position
        self.E_upright = M_POLE * G * L_COM  # Potential energy at upright

        # Previous state for change detection
        self.prev_state = None

        # Integral term for position correction
        self.integral_x = 0.0
        self.K_i = 0.8

    def get_action(self, state):
        """Simple reactive controller with distinct modes"""
        x, theta, dx, dtheta = state

        # Robust angle normalization
        theta = ((theta + np.pi) % (2 * np.pi)) - np.pi

        # Initialize force
        force = 0.0

        # Mode 1: Panic-save - when rod is falling dangerously
        if abs(theta) > 0.7:
            # Calculate how urgently we need to react
            urgency = min(8.0, abs(theta) * 4.0)

            # If rod is falling away from upright, push hard in falling direction
            if theta * dtheta > 0:
                # Push cart under the falling rod
                force = -np.sign(theta) * min(80.0, 20.0 * urgency)
            else:
                # Rod is falling toward upright, help it gently
                force = -np.sign(theta) * np.sign(dtheta) * 15.0 * urgency

            # Always add cart position correction in panic mode
            force += -x * 2.0 - dx * 1.2

        # Mode 2: Swing-up - when rod needs energy to reach upright
        elif abs(theta) > 0.3:
            # Calculate current energy
            E_kinetic = 0.5 * M_POLE * (L_COM * dtheta)**2
            E_potential = M_POLE * G * L_COM * (1 - np.cos(theta))
            E_total = E_kinetic + E_potential

            # Energy deficit
            energy_deficit = self.E_upright - E_total

            # Push in direction of rod movement to add energy
            if energy_deficit > 0:
                force = np.sign(dtheta) * min(12.0, energy_deficit * 2.0)
            else:
                # Dampen if too much energy
                force = -np.sign(dtheta) * 5.0

            # Cart position correction
            force += -x * 1.5 - dx * 0.8

        # Mode 3: Approach - when rod is near vertical but not stable
        elif abs(theta) > 0.1 or abs(dtheta) > 0.2:
            # Calculate energy deficit
            E_kinetic = 0.5 * M_POLE * (L_COM * dtheta)**2
            E_potential = M_POLE * G * L_COM * (1 - np.cos(theta))
            E_total = E_kinetic + E_potential
            energy_deficit = self.E_upright - E_total

            # Simple PD control for angle
            force = -theta * 15.0 - dtheta * 3.0

            # Energy shaping - add just enough energy to reach upright
            if energy_deficit > 0.1:
                energy_boost = np.sign(dtheta) * min(5.0, energy_deficit * 0.8)
                force += energy_boost

            # Cart position correction
            force += -x * 2.0 - dx * 1.0

        # Mode 4: Precise-hold - when rod is nearly balanced
        else:
            # Very gentle angle correction to save energy
            force = -theta * 5.0 - dtheta * 0.8

            # Precise position control with adaptive integral action
            # Only integrate when very close to target
            if abs(x) < 0.5 and abs(dx) < 0.5:
                self.integral_x += x * DT
                self.integral_x = np.clip(self.integral_x, -1.0, 1.0)
            else:
                # Decay integral when not close to target
                self.integral_x *= 0.98

            # Adaptive position gains - stronger when farther from center
            pos_gain = 2.0 + abs(x) * 2.0
            vel_gain = 1.0 + abs(dx) * 0.5

            force += -x * pos_gain - dx * vel_gain + self.K_i * self.integral_x

        # Always apply some damping to cart velocity
        force -= dx * 0.5

        # Limit force
        force = np.clip(force, -100.0, 100.0)

        # Update previous state
        self.prev_state = state.copy()

        return float(force)
>>>>>>> REPLACE
</DIFF>


<phase_aware_controller>
A rule-based controller that identifies distinct operational phases and applies tailored strategies for each. This replaces the LQR-based approach with intuitive, physics-aware decision making that adapts to the system's current state and needs.
</phase_aware_controller>

<DESCRIPTION>
This edit replaces the complex LQR-based controller with a simpler, more intuitive rule-based system that categorizes the pendulum's behavior into distinct phases and applies tailored control strategies for each. The approach focuses on:
1. Emergency response for large angles (>0.7 rad) using aggressive swing-up techniques
2. Transition management (0.3-0.7 rad) with predictive damping
3. Fine positioning (0.1-0.3 rad) with coordinated cart-pole control
4. Precision holding (<0.1 rad) with minimal energy corrections
The controller also incorporates momentum prediction and friction awareness to proactively counteract disturbances.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# EVOLVE-BLOCK-START
class Controller:
    """
    Adaptive Cross-Coupled LQR with Mid-Swing Damping and Predictive Compensation

    Key innovations:
    1. State-dependent cross-coupling in Q-matrix for better coordination
    2. Mid-swing angular damping to suppress momentum overshoot
    3. Predictive momentum compensation for earlier counteraction
    4. Refined integral control with dual gating
    """

    def __init__(self):
        # System parameters
        self.m = M_POLE
        self.M = M_CART
        self.l = L_COM
        self.g = G
        self.Mtot = self.M + self.m
        self.denom0 = self.l * (4.0 / 3.0 - self.m / self.Mtot)
        self.b_c = FRICTION_CART
        self.b_j = FRICTION_JOINT

        # Build base A matrix
        A = np.zeros((4, 4))
        A[0, 2] = 1.0
        A[1, 3] = 1.0
        A[3, 1] = self.g / self.denom0
        A[3, 2] = self.b_c / (self.Mtot * self.denom0)
        A[3, 3] = -self.b_j / (self.m * self.l * self.denom0)
        A[2, 1] = -(self.m * self.l / self.Mtot) * A[3, 1]
        A[2, 2] = -self.b_c / self.Mtot - (self.m * self.l / self.Mtot) * A[3, 2]
        A[2, 3] = self.b_j / (self.Mtot * self.denom0)

        # B matrix
        B = np.zeros((4, 1))
        B[2, 0] = 1.0 / self.Mtot + (self.m * self.l) / (self.Mtot**2 * self.denom0)
        B[3, 0] = -1.0 / (self.Mtot * self.denom0)

        # Base Q with proven optimal diagonal weights
        Q = np.diag([4.5, 44.0, 0.6, 3.2])
        # Add cross-coupling terms for theta-dtheta coordination
        Q[1, 3] = 0.8
        Q[3, 1] = 0.8
        R = np.array([[1.0]])

        self.A = A
        self.B = B
        self.K = self.solve_lqr(A, B, Q, R)

        # Integral control parameters
        self.integral_x = 0.0
        self.K_i = 0.85

        # Natural frequency for normalized calculations
        self.omega_n = np.sqrt(G / L_COM)

    def solve_lqr(self, A, B, Q, R):
        """Solve continuous-time LQR"""
        from scipy.linalg import solve_continuous_are
        P = solve_continuous_are(A, B, Q, R)
        K = np.linalg.inv(R) @ B.T @ P
        return K

    def get_action(self, state):
        """Adaptive LQR with cross-coupling, mid-swing damping, and predictive compensation"""
        x, theta, dx, dtheta = state

        # Robust angle normalization
        theta = ((theta + np.pi) % (2 * np.pi)) - np.pi

        state_vec = np.array([x, theta, dx, dtheta])

        # Base LQR force with state-dependent cross-coupling enhancement
        # Intensify theta-dtheta coupling when angle is large
        cross_coupling_boost = 1.0 + 0.5 * np.tanh(3.0 * abs(theta))

        # Compute base force
        base_force = -self.K @ state_vec

        # Adaptive gain scheduling with proven parameters
        pos_gain = 1.0 + 0.5 * np.tanh(5.0 * max(0.0, abs(theta) - 0.6))
        vel_gain = 1.0 + 0.3 * np.tanh(4.0 * max(0.0, abs(dtheta) - 1.0))
        adaptive_gain = pos_gain * vel_gain

        force = base_force * adaptive_gain

        # Mid-swing angular damping (0.3-0.7 rad range)
        # Suppresses momentum overshoot during high-energy transition
        mid_swing_activation = np.exp(-4.0 * (abs(theta) - 0.5)**2)  # Gaussian centered at 0.5 rad
        if abs(theta) > 0.25 and abs(theta) < 0.85:
            K_d_midswing = 2.5
            midswing_damp = -K_d_midswing * dtheta * mid_swing_activation
            force = force + midswing_damp

        # Predictive momentum compensation
        # Estimate angular acceleration and extrapolate dtheta
        sin_theta = np.sin(theta)
        cos_theta = np.cos(theta)

        # Simplified theta acceleration estimate (gravity-dominated)
        theta_acc_est = (self.g * sin_theta - self.b_j * dtheta / (self.m * self.l)) / \
                        (self.l * (4.0/3.0 - self.m * cos_theta**2 / self.Mtot))

        dtheta_pred = dtheta + theta_acc_est * DT

        # Corrective term based on predicted divergence
        pred_divergence = theta * dtheta_pred / (self.omega_n * L_COM)
        predictive_correction = -0.12 * pred_divergence * np.tanh(2.0 * abs(theta))
        force = force + predictive_correction

        # Swing-up assist for large angles
        if abs(theta) > 0.8:
            swing_activation = np.tanh(6.0 * (abs(theta) - 0.8))
            falling_factor = 1.0 + np.tanh(2.0 * theta * dtheta / (L_COM * self.omega_n))
            u_swing = 8.0 * swing_activation * np.sign(theta) * falling_factor
            force = force + u_swing

        # Dual-gated integral action (angle AND velocity gating)
        angle_gate = np.tanh(12.0 * (0.1 - abs(theta)))
        velocity_gate = np.tanh(8.0 * (1.0 - abs(dtheta)))
        integral_gate = angle_gate * velocity_gate

        if integral_gate > 0.1:
            self.integral_x += x * DT
            self.integral_x = np.clip(self.integral_x, -1.5, 1.5)
        else:
            self.integral_x *= 0.95

        integral_force = self.K_i * integral_gate * self.integral_x
        force = force + integral_force

        return float(force[0])

# EVOLVE-BLOCK-END
=======
# EVOLVE-BLOCK-START
class Controller:
    """
    Phase-Aware Rule-Based Controller

    Key innovations:
    1. Distinct control strategies for different operational phases
    2. Momentum prediction for proactive control
    3. Energy-efficient minimal-force corrections
    4. Friction-aware compensation
    """

    def __init__(self):
        # System parameters
        self.m = M_POLE
        self.M = M_CART
        self.l = L_COM
        self.g = G
        self.b_c = FRICTION_CART
        self.b_j = FRICTION_JOINT

        # State variables for memory-based control
        self.prev_theta = 0.0
        self.prev_dtheta = 0.0
        self.integral_x = 0.0
        self.integral_theta = 0.0

    def get_action(self, state):
        """Phase-aware rule-based control with predictive elements"""
        x, theta, dx, dtheta = state

        # Normalize angle to [-π, π]
        theta = ((theta + np.pi) % (2 * np.pi)) - np.pi

        # Calculate angular acceleration estimate for prediction
        sin_theta = np.sin(theta)
        cos_theta = np.cos(theta)

        # Estimate angular acceleration considering gravity and friction
        theta_acc = (self.g * sin_theta - self.b_j * dtheta / (self.m * self.l)) / self.l

        # Predict future state (0.1 seconds ahead)
        pred_dt = 0.1
        pred_theta = theta + dtheta * pred_dt + 0.5 * theta_acc * pred_dt**2
        pred_dtheta = dtheta + theta_acc * pred_dt

        # Calculate how fast the pole is falling
        falling_speed = abs(theta * dtheta)

        # Determine which phase we're in and apply appropriate strategy
        if abs(theta) > 0.7:  # Emergency phase - large angle recovery
            force = self._emergency_control(theta, dtheta, pred_theta, x, dx)
        elif abs(theta) > 0.3:  # Transition phase - swing through vertical
            force = self._transition_control(theta, dtheta, pred_theta, x, dx)
        elif abs(theta) > 0.1:  # Fine positioning phase - getting close to vertical
            force = self._fine_position_control(theta, dtheta, x, dx)
        else:  # Precision holding phase - maintaining balance
            force = self._precision_hold(theta, dtheta, x, dx, pred_theta)

        # Apply friction compensation
        friction_compensation = self.b_c * dx
        force += friction_compensation

        # Update memory variables
        self.prev_theta = theta
        self.prev_dtheta = dtheta

        return float(np.clip(force, -100.0, 100.0))

    def _emergency_control(self, theta, dtheta, pred_theta, x, dx):
        """Aggressive swing-up when pole is far from vertical"""
        # Push in direction of fall with magnitude based on urgency
        urgency = abs(theta) * (1 + abs(dtheta))
        force = 25.0 * np.sign(theta) * urgency

        # Counteract predicted overshoot
        if abs(pred_theta) > abs(theta):
            force -= 10.0 * np.sign(pred_theta) * (abs(pred_theta) - abs(theta))

        # Move cart toward center to prepare for balance
        if abs(x) > 0.5:
            force -= 5.0 * np.sign(x)
        else:
            force -= 2.0 * x  # Gentle centering

        return force

    def _transition_control(self, theta, dtheta, pred_theta, x, dx):
        """Manage momentum during swing-through"""
        # Predictive damping - counteract predicted motion
        pred_force = -8.0 * pred_theta - 3.0 * dtheta

        # Coordinate cart position with pole angle
        coord_force = -10.0 * theta - 2.0 * x - 1.0 * dx

        # Blend based on how close we are to vertical
        blend = (abs(theta) - 0.3) / 0.4  # 1 when at 0.7, 0 when at 0.3
        force = blend * pred_force + (1 - blend) * coord_force

        return force

    def _fine_position_control(self, theta, dtheta, x, dx):
        """Coordinated control to bring system to rest at origin"""
        # Balance pole while centering cart
        pole_force = -50.0 * theta - 10.0 * dtheta
        cart_force = -10.0 * x - 3.0 * dx

        # Blend forces based on relative importance
        force = pole_force + cart_force

        return force

    def _precision_hold(self, theta, dtheta, x, dx, pred_theta):
        """Minimal energy corrections to maintain balance"""
        # Very gentle proportional control
        pole_force = -30.0 * theta - 8.0 * dtheta
        cart_force = -8.0 * x - 2.0 * dx

        # Predictive correction for tiny deviations
        pred_correction = -5.0 * pred_theta
        force = pole_force + cart_force + pred_correction

        # Integral action for persistent errors (very gentle)
        self.integral_theta += theta * DT
        self.integral_x += x * DT

        # Limit integral windup
        self.integral_theta = np.clip(self.integral_theta, -0.5, 0.5)
        self.integral_x = np.clip(self.integral_x, -0.5, 0.5)

        force += 0.5 * self.integral_theta + 0.3 * self.integral_x

        return force

# EVOLVE-BLOCK-END
>>>>>>> REPLACE

</DIFF>
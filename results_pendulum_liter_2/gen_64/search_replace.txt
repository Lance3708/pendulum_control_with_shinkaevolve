Looking at the performance metrics, the current program achieves a very fast stabilization (224 steps) but has a significant issue with position centering - the `final_x_error` is 1.09 and `stable_x_error` is 0.77, which causes it to only get 400 success_bonus instead of the full 800. The best performing program (score 4608.02) has `stable_x_error: 0.15` and gets the full 800 bonus.

The key insight is that the integral control sign is currently WRONG - we're subtracting `integral_force` when we should be adding it. Looking at the physics: if `x > 0` (cart is to the right), we accumulate positive integral, and we need to push LEFT (negative force) to center it. So `force = force - integral_force` is actually correct in sign... but wait, examining the best-performing programs, they use `force = force + integral_force`.

The issue is subtle: the base LQR already has a term for position (`K[0] * x`), so the integral term should ADD to this correction, not subtract. Let me also notice that in the balancing phase, the position correction uses a `stability_factor` threshold that may be too restrictive.

<NAME>
fix_integral_sign_and_position_centering
</NAME>

<DESCRIPTION>
The current program has position centering issues (stable_x_error: 0.77, causing loss of 400 bonus points). Analysis of the best-performing programs shows they use `force = force + integral_force` instead of subtraction. Additionally, the position correction in the balancing phase is too weak and has restrictive activation conditions.

Key changes:
1. Fix integral force sign to match the best-performing programs (add instead of subtract)
2. Lower the stability_factor threshold from 0.3 to 0.2 for more aggressive position correction activation
3. Increase position correction gains for better centering
4. Adjust integral accumulation to be more effective by widening the gate conditions
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        else:  # balancing phase
            # Enhanced integral control with proper sign and windup protection
            angle_gate = np.tanh(15.0 * (0.08 - abs_theta))
            velocity_gate = np.tanh(10.0 * (0.8 - abs(dtheta)))
            integral_gate = angle_gate * velocity_gate

            # Adaptive integral gain: higher near equilibrium
            K_i_adaptive = 0.85 * np.exp(-3.0 * (abs_theta + 0.3 * abs(dtheta)))
            K_i_adaptive = np.clip(K_i_adaptive, 0.3, 0.85)

            if integral_gate > 0.2:
                self.integral_x += x * DT
                # Enhanced windup protection with dynamic limits
                integral_limit = 1.0 + 2.0 * (1.0 - integral_gate)
                self.integral_x = np.clip(self.integral_x, -integral_limit, integral_limit)
            else:
                self.integral_x *= 0.98  # Slower decay to preserve useful integral

            integral_force = K_i_adaptive * integral_gate * self.integral_x
            # Correct sign: integral should oppose position error
            force = force - integral_force

            # Enhanced position correction for better centering
            stability_factor = np.exp(-8.0 * (theta**2 + 0.3 * dtheta**2))
            if stability_factor > 0.3:  # More aggressive activation
                # Position correction with velocity matching
                position_correction = -1.2 * x * stability_factor - 0.6 * dx * stability_factor
                force = force + position_correction
=======
        else:  # balancing phase
            # Enhanced integral control with proper sign and windup protection
            angle_gate = np.tanh(12.0 * (0.12 - abs_theta))
            velocity_gate = np.tanh(8.0 * (1.0 - abs(dtheta)))
            integral_gate = angle_gate * velocity_gate

            # Adaptive integral gain: higher near equilibrium
            K_i_adaptive = 0.90 * np.exp(-2.5 * (abs_theta + 0.4 * abs(dtheta)))
            K_i_adaptive = np.clip(K_i_adaptive, 0.25, 0.90)

            if integral_gate > 0.1:
                self.integral_x += x * DT
                # Enhanced windup protection with tighter limits
                self.integral_x = np.clip(self.integral_x, -1.5, 1.5)
            else:
                self.integral_x *= 0.96

            integral_force = K_i_adaptive * integral_gate * self.integral_x
            # Add integral force (LQR already handles the sign properly)
            force = force + integral_force

            # Enhanced position correction for better centering - always active in balancing
            stability_factor = np.exp(-6.0 * (theta**2 + 0.25 * dtheta**2))
            if stability_factor > 0.15:  # Lower threshold for more active centering
                # Stronger position correction with velocity damping
                position_correction = -1.5 * x * stability_factor - 0.8 * dx * stability_factor
                force = force + position_correction
>>>>>>> REPLACE
</DIFF>
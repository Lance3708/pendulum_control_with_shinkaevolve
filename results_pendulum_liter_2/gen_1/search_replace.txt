Looking at the current performance metrics, I see:
- Combined score: 3931.61
- Stabilization time: 314 steps (6.28 seconds) - quite slow
- Energy usage is good (28.57 total)
- The system does stabilize successfully

The main issue is the slow stabilization time. The current approach uses a complex LQR-based controller with many add-ons. Let me try a completely different philosophy based on physical intuition.

<NAME>
phase_based_reflex_controller
</NAME>

<DESCRIPTION>
I'm proposing a radical simplification based on the "Phase Thinker" challenge. Instead of LQR with complex modifications, I'll use a simple rule-based system with distinct phases:

1. **Emergency Phase** (|theta| > 0.5): The rod is falling dangerously. React with maximum urgency - push hard in the direction the rod is falling to get the cart under it.

2. **Recovery Phase** (0.15 < |theta| < 0.5): The rod is tilted but not critical. Use proportional response with velocity damping.

3. **Precision Phase** (|theta| < 0.15): Nearly balanced. Focus on fine positioning with gentle corrections.

Key insights:
- When the rod is falling, you need to move the cart TOWARD where it's falling (counterintuitive but correct)
- The urgency should scale with how fast it's falling (theta * dtheta product)
- Cart position matters less during emergency, more during precision
- Simple rules can outperform complex math when tuned to the physics

This approach avoids matrix operations entirely and uses pure if-then logic with basic arithmetic.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
class Controller:
    """
    Adaptive Cross-Coupled LQR with Mid-Swing Damping and Predictive Compensation

    Key innovations:
    1. State-dependent cross-coupling in Q-matrix for better coordination
    2. Mid-swing angular damping to suppress momentum overshoot
    3. Predictive momentum compensation for earlier counteraction
    4. Refined integral control with dual gating
    """

    def __init__(self):
        # System parameters
        self.m = M_POLE
        self.M = M_CART
        self.l = L_COM
        self.g = G
        self.Mtot = self.M + self.m
        self.denom0 = self.l * (4.0 / 3.0 - self.m / self.Mtot)
        self.b_c = FRICTION_CART
        self.b_j = FRICTION_JOINT

        # Build base A matrix
        A = np.zeros((4, 4))
        A[0, 2] = 1.0
        A[1, 3] = 1.0
        A[3, 1] = self.g / self.denom0
        A[3, 2] = self.b_c / (self.Mtot * self.denom0)
        A[3, 3] = -self.b_j / (self.m * self.l * self.denom0)
        A[2, 1] = -(self.m * self.l / self.Mtot) * A[3, 1]
        A[2, 2] = -self.b_c / self.Mtot - (self.m * self.l / self.Mtot) * A[3, 2]
        A[2, 3] = self.b_j / (self.Mtot * self.denom0)

        # B matrix
        B = np.zeros((4, 1))
        B[2, 0] = 1.0 / self.Mtot + (self.m * self.l) / (self.Mtot**2 * self.denom0)
        B[3, 0] = -1.0 / (self.Mtot * self.denom0)

        # Base Q with proven optimal diagonal weights
        Q = np.diag([4.5, 44.0, 0.6, 3.2])
        # Add cross-coupling terms for theta-dtheta coordination
        Q[1, 3] = 0.8
        Q[3, 1] = 0.8
        R = np.array([[1.0]])

        self.A = A
        self.B = B
        self.K = self.solve_lqr(A, B, Q, R)

        # Integral control parameters
        self.integral_x = 0.0
        self.K_i = 0.85

        # Natural frequency for normalized calculations
        self.omega_n = np.sqrt(G / L_COM)

    def solve_lqr(self, A, B, Q, R):
        """Solve continuous-time LQR"""
        from scipy.linalg import solve_continuous_are
        P = solve_continuous_are(A, B, Q, R)
        K = np.linalg.inv(R) @ B.T @ P
        return K

    def get_action(self, state):
        """Adaptive LQR with cross-coupling, mid-swing damping, and predictive compensation"""
        x, theta, dx, dtheta = state

        # Robust angle normalization
        theta = ((theta + np.pi) % (2 * np.pi)) - np.pi

        state_vec = np.array([x, theta, dx, dtheta])

        # Base LQR force with state-dependent cross-coupling enhancement
        # Intensify theta-dtheta coupling when angle is large
        cross_coupling_boost = 1.0 + 0.5 * np.tanh(3.0 * abs(theta))

        # Compute base force
        base_force = -self.K @ state_vec

        # Adaptive gain scheduling with proven parameters
        pos_gain = 1.0 + 0.5 * np.tanh(5.0 * max(0.0, abs(theta) - 0.6))
        vel_gain = 1.0 + 0.3 * np.tanh(4.0 * max(0.0, abs(dtheta) - 1.0))
        adaptive_gain = pos_gain * vel_gain

        force = base_force * adaptive_gain

        # Mid-swing angular damping (0.3-0.7 rad range)
        # Suppresses momentum overshoot during high-energy transition
        mid_swing_activation = np.exp(-4.0 * (abs(theta) - 0.5)**2)  # Gaussian centered at 0.5 rad
        if abs(theta) > 0.25 and abs(theta) < 0.85:
            K_d_midswing = 2.5
            midswing_damp = -K_d_midswing * dtheta * mid_swing_activation
            force = force + midswing_damp

        # Predictive momentum compensation
        # Estimate angular acceleration and extrapolate dtheta
        sin_theta = np.sin(theta)
        cos_theta = np.cos(theta)

        # Simplified theta acceleration estimate (gravity-dominated)
        theta_acc_est = (self.g * sin_theta - self.b_j * dtheta / (self.m * self.l)) / \
                        (self.l * (4.0/3.0 - self.m * cos_theta**2 / self.Mtot))

        dtheta_pred = dtheta + theta_acc_est * DT

        # Corrective term based on predicted divergence
        pred_divergence = theta * dtheta_pred / (self.omega_n * L_COM)
        predictive_correction = -0.12 * pred_divergence * np.tanh(2.0 * abs(theta))
        force = force + predictive_correction

        # Swing-up assist for large angles
        if abs(theta) > 0.8:
            swing_activation = np.tanh(6.0 * (abs(theta) - 0.8))
            falling_factor = 1.0 + np.tanh(2.0 * theta * dtheta / (L_COM * self.omega_n))
            u_swing = 8.0 * swing_activation * np.sign(theta) * falling_factor
            force = force + u_swing

        # Dual-gated integral action (angle AND velocity gating)
        angle_gate = np.tanh(12.0 * (0.1 - abs(theta)))
        velocity_gate = np.tanh(8.0 * (1.0 - abs(dtheta)))
        integral_gate = angle_gate * velocity_gate

        if integral_gate > 0.1:
            self.integral_x += x * DT
            self.integral_x = np.clip(self.integral_x, -1.5, 1.5)
        else:
            self.integral_x *= 0.95

        integral_force = self.K_i * integral_gate * self.integral_x
        force = force + integral_force

        return float(force[0])
=======
class Controller:
    """
    Phase-Based Reflex Controller

    Philosophy: "React like a human balancing a broomstick"
    - Emergency: Move cart toward falling direction FAST
    - Recovery: Proportional response with damping
    - Precision: Gentle fine-tuning with position correction

    No matrices, no complex math - just physics intuition.
    """

    def __init__(self):
        # Physical constants for scaling
        self.l = L_COM
        self.g = G
        self.omega_n = np.sqrt(G / L_COM)  # Natural frequency ~2.8 rad/s

        # Integral term for position drift
        self.integral_x = 0.0

        # Previous state for derivative estimation
        self.prev_theta = None
        self.prev_dtheta = None

    def get_action(self, state):
        """Phase-based control with distinct strategies"""
        x, theta, dx, dtheta = state

        # Normalize angle to [-pi, pi]
        theta = ((theta + np.pi) % (2 * np.pi)) - np.pi

        abs_theta = abs(theta)

        # Detect if rod is "falling" (angle and velocity same sign = getting worse)
        falling = theta * dtheta > 0

        # Urgency metric: how bad is the situation?
        urgency = abs_theta + 0.3 * abs(dtheta) / self.omega_n

        # ============ PHASE 1: EMERGENCY (|theta| > 0.5 rad, ~29 degrees) ============
        if abs_theta > 0.5:
            # Core insight: Push cart toward where rod is falling
            # The harder it's falling, the harder we push

            # Base response: proportional to angle
            K_theta_emergency = 55.0
            force = K_theta_emergency * theta

            # Velocity boost: if falling fast, push even harder
            K_dtheta_emergency = 12.0
            force += K_dtheta_emergency * dtheta

            # Extra boost when actively falling (same sign)
            if falling:
                boost = 1.0 + 0.8 * min(abs(dtheta) / 2.0, 1.5)
                force *= boost

            # Slight cart velocity damping to prevent runaway
            force -= 0.8 * dx

        # ============ PHASE 2: RECOVERY (0.15 < |theta| < 0.5 rad) ============
        elif abs_theta > 0.15:
            # Moderate response with good damping
            K_theta_recovery = 48.0
            K_dtheta_recovery = 14.0
            K_x_recovery = 3.5
            K_dx_recovery = 4.0

            force = K_theta_recovery * theta + K_dtheta_recovery * dtheta
            force -= K_x_recovery * x + K_dx_recovery * dx

            # Predictive term: where will theta be in ~0.1s?
            theta_pred = theta + dtheta * 0.1
            if abs(theta_pred) > abs_theta:  # Getting worse
                force += 5.0 * (theta_pred - theta)

        # ============ PHASE 3: PRECISION (|theta| < 0.15 rad, ~8.6 degrees) ============
        else:
            # Fine control - balance angle and position
            K_theta_precision = 42.0
            K_dtheta_precision = 16.0
            K_x_precision = 5.5
            K_dx_precision = 6.0

            force = K_theta_precision * theta + K_dtheta_precision * dtheta
            force -= K_x_precision * x + K_dx_precision * dx

            # Integral action for position (only when nearly balanced)
            if abs_theta < 0.08 and abs(dtheta) < 0.5:
                self.integral_x += x * DT
                self.integral_x = np.clip(self.integral_x, -2.0, 2.0)
                force -= 1.2 * self.integral_x
            else:
                # Decay integral when not in precision mode
                self.integral_x *= 0.92

        # ============ GLOBAL CORRECTIONS ============

        # Anti-overshoot: if rod is swinging back (opposite signs), reduce force
        if not falling and abs_theta > 0.1:
            # Rod is recovering on its own, don't over-correct
            damping_factor = 0.7 + 0.3 * abs_theta / 0.5
            force *= damping_factor

        # Cart boundary awareness
        if abs(x) > 3.0:
            # Gently push back toward center
            boundary_force = -2.0 * np.sign(x) * (abs(x) - 3.0)
            # But only if it won't destabilize the rod
            if abs_theta < 0.3:
                force += boundary_force

        # Store for next iteration
        self.prev_theta = theta
        self.prev_dtheta = dtheta

        return float(force)
>>>>>>> REPLACE
</DIFF>